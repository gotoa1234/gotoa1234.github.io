---
layout: default_post
title: "0002. Mysql 8.0 降序索引對查詢的效能優化有多少"
excerpt: "效能議題"
tags: Mysql DataBase
---

<div class="summary">
<br/>&emsp;&emsp;結論：用utf8mb4
<br/>問題討論：探討Mysql 8.0 降序索引配置，在何種情境下使用可以提高查詢效率、效能。
<br/>基本介紹：本篇分為5大部分。
<br/>第一部分：創建升序、降序索引
<br/>第二部分：升序和降序排序的區別
<br/>第三部分：升序索引 vs 降序索引效能測試
<br/>第四部分：結論-降序索引適合場景
</div>

<div class="title">
    <br/><hr class="titleinner">
	<span></span>
	<hr class="titleinner"><br/>
</div>

<br/><br/>

<h1>第一部分：創建升序、降序索引</h1>

<h2>Step 1：官方預設索引</h2>
參考官方：<a href="https://dev.mysql.com/doc/refman/8.0/en/create-index.html">建立索引說明</a>
<br/>看重點框選的地方，翻譯成中文大意就是：
<br/>1. Mysql官方建立索引時可以決定 ASC (升序)或者 DESC (降序)
<br/>2. 如果沒有設定，預設為 ASC (升序)
<br/> <img src="/assets/image/PerformanceIssue/2024_03_03/001.png" width="50%" height="50%" />
<br/><br/>

<h2>Step 2：創建[升序索引]舉例語法</h2>
以下是創建測試資料表 'test_asc' ，此表視為 Log表。
<br/>其中時間(CreateTime)紀錄為 'TIMESTAMP(6)' 記錄到毫秒第6位，便於說明。

```sql
-- 1. 創建資料表
CREATE TABLE test_asc (
    Logid INT NOT NULL PRIMARY KEY AUTO_INCREMENT,
    LogInfo VARCHAR(255) DEFAULT '',
    CreateTime TIMESTAMP(6) DEFAULT CURRENT_TIMESTAMP(6)
);


-- 2. 在 CreateTime 欄位上創建升序索引
CREATE INDEX idx_CreateTime_asc ON test_asc (CreateTime ASC);

-- 3. 單筆插入可以看到毫秒數
INSERT INTO test_asc(LogInfo) VALUE('testLog');
INSERT INTO test_asc(LogInfo) VALUE('testLog');
INSERT INTO test_asc(LogInfo) VALUE('testLog');
INSERT INTO test_asc(LogInfo) VALUE('testLog');
INSERT INTO test_asc(LogInfo) VALUE('testLog');

-- 4. 捨棄批次插入，跳過 Mysql 對 CURRENT_TIMESTAMP(6) 緩存
INSERT INTO test_asc(LogInfo)
VALUES('testLog'),
VALUES('testLog'),
VALUES('testLog'),
...
VALUES('testLog');

```

<br/><br/>

<h2>Step 3：創建[升序索引]舉例語法-補充說明1</h2>
關於此段語法：

```sql
-- 2. 在 CreateTime 欄位上創建升序索引
CREATE INDEX idx_CreateTime_asc ON test_asc (CreateTime ASC);
```

<br/>創建索引預設都是用 ASC(升序)，也就是以下，這裡完整帶出。

```sql
CREATE INDEX idx_CreateTime_asc ON test_asc (CreateTime);
```

<br/><br/>

<h2>Step 4：創建[升序索引]舉例語法-補充說明2</h2>
為了便於看出資料差異，不能用Bulk Insert ，當用Bulk Insert時，整批的 CURRENT_TIMESTAMP(6) 會視為同一筆。
<br/>為了觀察插入資料的毫秒差，改成單筆插入

```sql
-- 3. 單筆插入可以看到毫秒數
INSERT INTO test_asc(LogInfo) VALUE('testLog');
INSERT INTO test_asc(LogInfo) VALUE('testLog');
INSERT INTO test_asc(LogInfo) VALUE('testLog');
INSERT INTO test_asc(LogInfo) VALUE('testLog');
INSERT INTO test_asc(LogInfo) VALUE('testLog');

-- 4. 捨棄批次插入，跳過 Mysql 對 CURRENT_TIMESTAMP(6) 緩存
INSERT INTO test_asc(LogInfo)
VALUES('testLog'),
VALUES('testLog'),
VALUES('testLog'),
...
VALUES('testLog');

```

<br/><br/>

<h2>Step 5：創建[降序索引]語法</h2>
以下是創建測試資料表 'test_desc' ，此表視為 Log表。
<br/>與[升序索引]的差別在於 2. 在 id 欄位上創建降序索引，改成 DESC 排序

```sql
-- 1. 創建資料表
CREATE TABLE test_desc (
    Logid INT NOT NULL PRIMARY KEY AUTO_INCREMENT,
    LogInfo VARCHAR(255) DEFAULT '',
    CreateTime TIMESTAMP(6) DEFAULT CURRENT_TIMESTAMP(6)
);

-- 2. 在 id 欄位上創建降序索引
CREATE INDEX idx_CreateTime_desc ON test_desc (CreateTime DESC);

-- 3. 單筆插入可以看到毫秒數
INSERT INTO test_desc(LogInfo) VALUE('testLog');
INSERT INTO test_desc(LogInfo) VALUE('testLog');
INSERT INTO test_desc(LogInfo) VALUE('testLog');
INSERT INTO test_desc(LogInfo) VALUE('testLog');
INSERT INTO test_desc(LogInfo) VALUE('testLog');


-- 4. 捨棄批次插入，跳過 Mysql 對 CURRENT_TIMESTAMP(6) 緩存
INSERT INTO test_desc(LogInfo)
VALUES('testLog'),
VALUES('testLog'),
VALUES('testLog'),
...
VALUES('testLog');

```

<br/><br/>

<h1>第二部分：升序和降序排序的區別</h1>

<h2>Step 1：預設查詢 - 無效</h2>
無效的原因：等於全查，Filter效果為0，並且條件式不含 CreateTime，因此不降序排序
<br/>

```sql
-- 查詢升序表
SELECT Logid,CreateTime,LogInfo FROM test_asc;
-- 查詢降序表
SELECT Logid,CreateTime,LogInfo FROM test_desc;

```

<br/> <img src="/assets/image/PerformanceIssue/2024_03_03/002.png" width="50%" height="50%" />
<br/><br/>

<h2>Step 2：查詢-包含非索引欄位 - 無效</h2>
無效的原因：LogInfo 未吃到索引，並且條件式不含 CreateTime，因此不降序排序
<br/>

```sql
-- 查詢升序表
SELECT CreateTime,LogInfo FROM test_asc;
-- 查詢降序表
SELECT CreateTime,LogInfo FROM test_desc;

```

<br/> <img src="/assets/image/PerformanceIssue/2024_03_03/003.png" width="50%" height="50%" />
<br/><br/>

<h2>Step 3：查詢-只有索引欄位 - 有效</h2>
有效的原因：Logid 是主鍵 + CreateTime 有建立索引，因此條件式影響結果
<br/>

```sql
-- 查詢升序表
SELECT CreateTime,LogInfo FROM test_asc;
-- 查詢降序表
SELECT CreateTime,LogInfo FROM test_desc;

```

<br/> <img src="/assets/image/PerformanceIssue/2024_03_03/004.png" width="50%" height="50%" />
<br/><br/>

<h2>Step 4：查詢-條件式含索引欄位 - 有效</h2>
有效的原因：條件式包含索引條件，因此有[降序索引]的效果
<br/>

```sql
-- 查詢升序表
SELECT Logid,CreateTime,LogInfo FROM test_asc WHERE CreateTime > '2024-02-02 14:44:55.53000';
-- 查詢降序表
SELECT Logid,CreateTime,LogInfo FROM test_desc  WHERE CreateTime > '2024-02-02 14:47:10.60000';

```

<br/> <img src="/assets/image/PerformanceIssue/2024_03_03/005.png" width="50%" height="50%" />
<br/><br/>

<h2>Step 5：升序和降序排序的區別</h2>
上述四種是常見的基本查詢方式，這個效果是針對特殊狀況才會生效，在預設情況，欄位並不會被影響(預設始終是 ASC 升序排序)。

{:class="table table-bordered"}
| 查詢內容 | 是否有降序索引效果 |
| --- | --- |
| 預設 | 無效 |
| 包含非索引欄位 | 無效 |
| 只有索引欄位 | 有效 |
| 條件式含索引欄位 | 有效 |

<br/><br/>

<h1>第三部分：升序索引 vs 降序索引效能測試</h1>

<h2>Step 1：計算方式</h2>
因此決定能壓縮多少空間就看char、varchar等欄位，其他可以不計
<br/>假設資料庫全部都是utf8mb4，改為全都是utf8mb3可以解省的空間簡單計算如下：
<br/>使用空間值 * [(文字欄位) / 找出資料庫所有欄位] * (1 - 0.58) = 節省的空間

<br/> <img src="/assets/image/PerformanceIssue/2024_03_03/001.png" width="50%" height="50%" />
<br/><br/>

<br/><br/>

<h1>第四部分：結論-降序索引適合場景</h1>

<br/><a href="https://www.unicode.org/versions/Unicode15.0.0/">Unicode 官網</a>
<br/>最近一次更新的版本是 2022/09/13 15.0 版本
<br/>大意是說：新增幾個語言、支援新的表情符號，有持續加新的碼
<br/>如果系統要走進國際化(翻譯多國語言)，建議聽從官方建議使用 utf8mb4，捨棄 utf8mb3
<br/> <img src="/assets/image/PerformanceIssue/2024_03_03/001.png" width="50%" height="50%" />
<br/><br/>

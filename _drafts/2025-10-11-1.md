---
layout: default_post
title: "0005. Mysql 連線異常 - See wait_timeout and interactive_timeout for configuring this behavior. 與連線池效能說明"
excerpt: "效能議題"
tags:
  - "Mysql"  
  - "C#"  
  - "Kafka"  
---

<div class="summary">
<br/>相關參考：<a href="https://gotoa1234.github.io/2025/06/21/1.html">Mysql官網</a>
<br/>探討問題：1. 作者在工作環境上，看到不可思議的錯誤 Mysql 預設 8 小時才視為超時連線，怎麼樣才能觸發這種狀況
<br/>&emsp;&emsp;&emsp;&emsp;&emsp;2. 此問題實務上是如何出現，與 Mysql 連線池的關係
<br/>基本介紹：本篇分為四大部分。
<br/>第一部分：說明問題
<br/>第二部分：重現此問題代碼說明
<br/>第三部分：工作環境中如何出現
<br/>第四部分：分析結果 & 結論
</div>

<div class="title">
    <br/><hr class="titleinner">
  <span></span>
  <hr class="titleinner"><br/>
</div>

<br/><br/>
<h1>第一部分：說明問題</h1>


<h2>Step 1：原因 - 收到此錯誤信</h2>
關鍵字如下：

``` Markdown
Unhandled exception. MySql.Data.MySqlClient.MySqlException (0x80004005): The client was disconnected by the server because of inactivity. See wait_timeout and interactive_timeout for configuring this behavior.
```

<br/>Mysql 預設是連線後超過 8 個小時候會斷線，但實務上沒有**軟體工程師**會將連線與 Mysql 保持連線後，超過 8 小時都不執行 SQL 
<br/> <img src="/assets/image/PerformanceIssue/2025_10_11/002.png" alt="" width="50%" height="50%" />
<br/><br/>


<h2>Step 2：原因 - 檢查 Mysql 資料庫設定</h2>
檢查連線閒置時間是否太短，**wait_timeout** 或 **interactive_timeout**

``` SQL
SHOW VARIABLES LIKE 'wait_timeout';
SHOW VARIABLES LIKE 'interactive_timeout';
```

<br/>可以確定都是預設值，那麼問題的原因 8、9不離10 是在**代碼層面**上
<br/> <img src="/assets/image/PerformanceIssue/2025_10_11/001.png" alt="" width="50%" height="50%" />
<br/><br/>



<br/><br/>
<h1>第二部分：重現此問題代碼說明</h1>


<h2>Step 1： 測試代碼</h2>
以下是測試用的範例代碼，有 5 個部分

{:class="table table-bordered"}
|  描述    | 補充    |
|  ---    |  ---    |
|  1. 設定超時為 10 秒 (為了重現問題，8 小時太久) |    |
|  2. 首次查詢    |     |
|  3. 等待 15 秒，為了閒置超時    |     |
|  4. 第二次查詢      |  這時就會重現問題   |
|  5. 關閉      |    |


``` C#
using MySql.Data.MySqlClient;

class Program
{
    static async Task Main()
    {
        // 替換成你的 MySQL 連線字串
        string connStr = "Server=192.168.51.93;Port=3800;Database=demo;User ID=XXXX;Password=XXXX;max pool size=100";

        try
        {
            using (var conn = new MySqlConnection(connStr))
            {
                await conn.OpenAsync();
                Console.WriteLine("連線成功");

                // 1. 設定 SESSION wait_timeout = 10 秒
                using (var cmd = new MySqlCommand("SET SESSION wait_timeout=10;", conn))
                {
                    await cmd.ExecuteNonQueryAsync();
                    Console.WriteLine("SESSION wait_timeout 設為 10 秒");
                }

                // 2. 第一次查詢 (應該正常)
                using (var cmd = new MySqlCommand("SELECT NOW();", conn))
                {
                    var result = await cmd.ExecuteScalarAsync();
                    Console.WriteLine($"第一次查詢結果: {result}");
                }

                // 3. 等待 15 秒，超過 wait_timeout
                Console.WriteLine("等待 15 秒，模擬閒置超時...");
                await Task.Delay(TimeSpan.FromSeconds(15));

                try
                {
                    // 4. 第二次查詢 (此時連線應該已被 MySQL 斷掉)
                    using (var cmd = new MySqlCommand("SELECT NOW();", conn))
                    {
                        var result = await cmd.ExecuteScalarAsync();
                        Console.WriteLine($"第二次查詢結果: {result}");
                    }
                }
                catch (MySqlException ex)
                {
                    Console.WriteLine("捕捉到 MySqlException:");
                    Console.WriteLine(ex);
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine(ex);
        }
        // 5. 結束
        Console.WriteLine("程式結束");
    }
}

```

<br/><br/>

<h2>Step 2： 首次查詢 - 開始閒置</h2>
我們使用測試代碼，進入閒置狀態 (執行 Open 連線後的等待)
<br/> <img src="/assets/image/PerformanceIssue/2025_10_11/003.png" alt="" width="50%" height="50%" />
<br/><br/>

<h2>Step 3： 二次查詢 - 報錯</h2>
因為我們 Session Timeout 設為 10 秒，閒置 15 秒後再次繼續執行 SQL 因此報錯，重現了此問題
<br/>工作環境上竟然會有 8 小時等待，這相當匪夷所思
<br/> <img src="/assets/image/PerformanceIssue/2025_10_11/004.png" alt="" width="50%" height="50%" />
<br/><br/>



<br/><br/>
<h1>第三部分：工作環境中如何出現</h1>


<h2>Step 1：工作環境代碼 - 服務</h2>
在工作環境中在 Worker 服務啟動後，會讓 Kafka 持續監聽，以便執行消費者處理
<br/>這段 scope 生命週期錯誤，在消費者外部執行 CreateScope();
<br/>

{:class="table table-bordered"}
|  問題點 1  | 在消費者外部建立一次 Scope 接著整個生命周期都用相同的 DbConnection 處理(參考 Step 2. 連線方式) |

``` C#
public class MYWorkerService
{
    private IUnitOfWorkFactory? mywork;

    public async Task ExecuteAsync(CancellationToken cancellationToken)
    {
       
        try
        {
            // 略...

             // 【問題點 1】
            using var scope = scopeFactory.CreateScope();
            mywork = scope.ServiceProvider.GetRequiredService<IUnitOfWorkFactory>(); 

            await kafkaConsumer.SubscribeAsync<MyKafkaConsumer>(async (data) =>
            {
                try
                {                    
                    await Process();                 
                }
                catch (Exception ex)
                {
                    // 略...
                }
            });
        }
        catch (Exception ex)
        {
           // 略...
        }
    }

    private void Process()
    {
         // 【問題點 1】
        mywork.SqlQuery();
    }
}
```

<br/><br/>


<h2>Step 2：工作環境代碼 - 資料庫實例</h2>
但是執行底層的資料庫操作時，就有問題了

{:class="table table-bordered"}
|  問題點 2  | 將資料庫的 MySqlConnection 設定字典變數放在緩存中 |
|  問題點 3  | 若已存在緩存裡，就用相同的 MySqlConnection |

<br/>**最大的謬誤**：直覺地看，用 **Kafka 會持續監聽**，可能會有高併發突然數百萬的消費者，**用同個連線應該很合理**?


``` C#
public class DbConnectionFactory(MyOptions myOptions, ILogger<DbConnectionFactory> logger)
    : FactoryBase(new MySqlConnection(DbConnectionString)), IDbConnectionFactory
{
    // 【問題點 2】
    private readonly ConcurrentDictionary<(int AId, int BId, int ControlId, CategoryEnum ResourceType), DbConnection> _dbConnectionDict = [];

    // 大量的 Mysql Method 略...

    private DbConnection GetConnection((int AId, int BId, int ControlId, CategoryEnum ResourceType) key)
    {
        if (!_dbConnectionDict.TryGetValue(key, out var dbConnection))
        {
            //略...
         
            var connectionString = GetDbConnectionStringAsync(
                key.ControlId,
                key.AId, key.BId, key.ResourceType).Result;

            dbConnection = new MySqlConnection(connectionString);

            // 略...

            // 【問題點 3】
            _dbConnectionDict.TryAdd(key, dbConnection);

            // 略...
        }

        return dbConnection;
    }
}
```

<br/><br/>

<h2>Step 3：資料庫緩存的謬誤 - 圖解說明</h2>
實際上不應該緩存，因為緩存的結果會如下圖，導致第一次 Kafak 觸發後會建立 Dbconnection 然後放在緩存裡
<br/>只要如圖等待 8 小時都沒有工作時 (事務上我們的此服務為了高可用，會建立主主服務，因此會有一台未工作的狀況)
<br/>最終就會觸發此問題

<br/> <img src="/assets/image/PerformanceIssue/2025_10_11/xxx.png" alt="" width="50%" height="50%" />
<br/><br/>






<br/><br/>
<h1>第四部分：分析結果 & 結論</h1>


<h2>Step 1：分析結果 - DB連線使用緩存的影響</h2>
暴力一點的做法可以將 8 小時，延長至很長，但真正的危險在於 **Mysql 連線池**
<br/>資料庫連線如下，使用了 Max Pool size = 100 ，意思是這個連線可以用到最大 100 個連線，交給 Mysql 幫我管理

``` C#
string connStr = "Server=192.168.51.93;Port=3800;Database=demo;User ID=XXXX;Password=XXXX;max pool size=100";
```

<br/> <img src="/assets/image/PerformanceIssue/2025_10_11/000.png" alt="" width="50%" height="50%" />
<br/><br/>



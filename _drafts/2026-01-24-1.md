---
layout: default_post
title:  "0003. MRU(Most Recently Used Cache) - 快取演算法 (Cache Algorithm) - 快取策略：最近被使用的資料優先刪除"
excerpt: "演算法-快取策略"
tags:
- "Algorithm Cache"
- "Algorithm"
- "C#"
- "Asp.NET Core"
---

<div class="summary">
<br/>n：設定快取的上限筆數
<br/>時間複雜度(Time Complex)：O(1) ※ 取值 / 存值
<br/>空間複雜度： O(n)
<br/>範例檔案：<a href="https://github.com/gotoa1234/Algorithm_Cache/blob/main/Algorithm_Cache/Cache/MostRecentlyUsedAlgorithm.cs">Source Code</a>
<br/>範例專案：<a href="https://github.com/gotoa1234/Algorithm_Cache.git">Code Project</a>
<br/>基本介紹：本篇分為4大部分。
<br/>第一部分：MRU演算法 - 介紹
<br/>第二部分：MRU演算法 - 實現
<br/>第三部分：MRU演算法 - 圖解流程
<br/>第四部分：補充說明
</div>

<div class="title">
    <br/><hr class="titleinner">
	<span></span>
	<hr class="titleinner"><br/>
</div>


<br/><br/>
<h1>第一部分：LFU演算法 - 介紹</h1>
<h2>Step 1：簡介</h2>
以下截取於<a href="https://en.wikipedia.org/wiki/Cache_replacement_policies#LFU">Wiki</a>

``` Markdown
Most-recently-used (MRU)
Unlike LRU, MRU discards the most-recently-used items first. 
At the 11th VLDB conference, Chou and DeWitt said: "When a file is being repeatedly scanned in a [looping sequential] reference pattern, 
MRU is the best replacement algorithm.
```

<br/>簡言之：「最近被使用的資料優先刪除」，最後用到的物件權重最低，用此演算法通常適合應用文檔或多步撤銷系統
<br/>※來源：Wiki
<br/><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/7e/Comparison_computational_complexity.svg/1024px-Comparison_computational_complexity.svg.png" width="100%" height="100%" />
<br/><br/>

<h2>Step 2：優缺點  TODO</h2>
**優點**具有以下：

{:class="table table-bordered"}
| **1. 保留 最常被使用的資料** | Frequency 累積能讓真正熱門的 key 長期保留，不會因短期不用而被淘汰。 |
| **2. O(1) 高效操作** | 使用 HashMap + freq-list（多組 LinkedList）可達到 O(1) 操作效率。 |
| **3. 適用於熱門資料明確的業務場景** | 如熱門文章、熱門商品、常用配置參數、熱鍵搜尋結果。 |
| **4. 能適應長期穩定熱點資料** | 越常被存取，留存時間越久，能有效提高快取命中率。 |

<br/>**缺點**：

{:class="table table-bordered"}
| **1. 實作複雜度較高** | 難度比 LRU 更高，且必須維護 頻率 → list 結構，並追蹤 key 的頻率。 |
| **2. 容易造成老資料霸佔快取** | 高頻資料可能永久佔位，除非加入「頻率衰減（decay）」機制。 |
| **3. 對瞬時爆量變動不敏感** | 短期熱門的資料可能因 頻率 累積不足而被誤刪。 |
| **4. 額外的記憶體與維護成本** | 多組 LinkedList 會消耗額外空間與運算資源。 |


<br/><br/>

<h2>Step 3：應用場景說明 TODO</h2>
以下列舉生活常見的 LFU Cache 應用，以及補充何種狀況下不合適採用

{:class="table table-bordered"}
| 場景 | 適合 LFU 的原因 | 不適用情況 | 實際生活例子             |
| ------------ | ----------------- | ------------------- | ------------------- |
| **1. 熱門內容長期固定**     | 頻率能準確累積熱門項目並保留 | 熱門項目短時間內頻繁變動      | 熱門文章排行榜、熱門搜尋建議          |
| **2. 使用者行為長期穩定**    | 能反映使用者長期偏好        | 需求依據瞬時行為判斷較多      | 像手機輸入法常用表情、常用詞彙         |
| **3. 熱點資料需要長期保留**   | 長期熱門內容不會被淘汰       | 近期資料比累積資料重要       | 網站首頁最熱賣商品               |
| **4. 預估長期命中率**      | 高頻資料長駐提升命中        | 老資料高頻率永久高優先權   | YouTube 自動在快取中保留長期高點閱影片 |
| **5. 適合資料不會短期爆量干擾** | 可防止短期爆量資料污染       | 遇批次大量讀取，cache 被洗掉 | 避免一次性備份掃描佔用 cache       |
| **6. 頻率具代表性**      | 高次數存取即高價值         | 資料生命週期短、無頻率意義     | 使用者常用設定（例如語言偏好）         |
| **7. 適合冷資料自然淡出**    | 頻率 直接代表資料重要性    | 只需要記錄近期使用時間       | AI 提供個人化常用推薦內容          |

<br/><br/>



<h1>第二部分：MRU演算法 - 實現</h1>
<h2>Step 1：完整代碼</h2>
完整代碼可以從<a href="https://github.com/gotoa1234/Algorithm_Cache/blob/main/Algorithm_Cache/Cache/MostRecentlyUsedAlgorithm.cs">Source Code</a>下載

<br/>主要以下 3 個部分完成，整理複雜度 + 完整代碼框架如下：
<br/>※關鍵差異 : 刪除的策略是最新的資料優先刪除

{:class="table table-bordered"}
| **1. 快取策略容量上限** | 空間複雜度 O(n) | MRU 同 LRU 需要 HashMap + LinkedList，兩者都持有 n 項資料，所以空間 O(n) |
| **2. 取值的處理** | 時間複雜度 O(1) | MRU 同 LRU，HashMap 取得節點 = O(1)，再更新鏈結位置 = O(1) |
| **3. 存值的處理** | 時間複雜度 O(1) | MRU 同 LRU，查找、插入/更新、鏈表調整全部都是 O(1) |


``` C#
public class MostRecentlyUsedAlgorithm
{
    public readonly int _capacity;
    public readonly Dictionary<string, LinkedListNode<(string key, string value)>> _cache;
    public readonly LinkedList<(string key, string value)> _links;

    /// <summary>
    /// 1. 建構式 - 快取策略容量上限
    /// </summary>
    public MostRecentlyUsedAlgorithm(int capacity)
    {
        _capacity = capacity;
        _cache = new Dictionary<string, LinkedListNode<(string key, string value)>>();
        _links = new LinkedList<(string key, string value)>();
    }

    /// <summary>
    /// 2. 取值的處理 (同 LRU 處理) 
    /// </summary>
    public string Get(string key)
    {
    }

    /// <summary>
    /// 3. 存值的處理
    /// </summary>
    public void Put(string key, string value)
    {
    }
}
```

<br/><br/>

<h2>Step 2：1. 快取策略容量上限</h2>
MRU 使用時，需決定保存快取上限
<br/>與 LRU 完全相同的初始配置

``` C#
/// <summary>
/// 1. 建構式 - 快取策略容量上限
/// </summary>
public MostRecentlyUsedAlgorithm(int capacity)
{
    _capacity = capacity;
    _cache = new Dictionary<string, LinkedListNode<(string key, string value)>>();
    _links = new LinkedList<(string key, string value)>();
}
```

<br/><br/>

<h2>Step 3：2. 取值的處理</h2>
取值的處理，每當被檢索到時，將權重 **降低**

``` C#
/// <summary>
/// 2. 取值的處理 (同 LRU 處理) 
/// </summary>
public string Get(string key)
{
    if (!_cache.ContainsKey(key))
        return string.Empty;

    var node = _cache[key];
    _links.Remove(node);
    _links.AddFirst(node);
    return node.Value.value;
}
```

<br/><br/>

<h2>Step 4：3. 存值的處理</h2>
存值的處理，當存入時，有 2 個方向，共 3 種情況，關鍵差異在 **刪除**

{:class="table table-bordered"}
| 是否已存在 | 是否達到設定上限 | 處理方式 |
| --- |  --- | --- |
| 存在 | | 更新 Key 的 Value 值 並且將權重降到最低   | 
| 不存在 | 是 | 移除權重最低的資料 + 新增 Key 的 Value 值 並且最低權重 |
| 不存在 | 否 | 新增 Key 的 Value 值 並且最低權重 |

``` C#
/// <summary>
/// 3. 存值的處理
/// </summary>
public void Put(string key, string value)
{
    // 3-1. 存在的狀況同 LRU 
    if (_cache.ContainsKey(key))
    {                
        var node = _cache[key];
        _cache.Remove(node.Value.key);
        _links.Remove(node);

        var newNode = _links.AddFirst((key, value));
        _cache[key] = newNode;
    }
    else 
    {
        // 3-2. [關鍵] MRU 與 LRU 關鍵差異在刪除的快取策略
        if (_cache.Count() >= _capacity)
        {
            // MRU 刪除最近使用的 : 與 FRU 差異在此
            var firstNode = _links.First;                
            _cache.Remove(firstNode.Value.key);          
            _links.RemoveFirst();
        }

        var newNode = _links.AddFirst((key, value));
        _cache[key] = newNode;
    }
}
```

<br/><br/>


<h2>Step 5：DEMO - 成功執行結果</h2>
附上代碼執行結果，此結果是與 Wiki 上的範例 & 結果一致
{:class="table table-bordered"}
| 依序放入(全是 Put) | A B C D E C D B |
| 執行結果(權重低到高) | B D E A |

<br/> <img src="/assets/image/Algorithm/Cache/MRU/001.png" width="50%" height="50%">
<br/>
<br/>對應 <a href="https://en.wikipedia.org/wiki/Cache_replacement_policies#Most-recently-used_(MRU)">Wiki 的 MRU 範例</a>
<br/> <img src="https://upload.wikimedia.org/wikipedia/commons/4/43/Mruexample.png" width="50%" height="50%">
<br/><br/>



<h1>第三部分：MRU演算法 - 圖解流程</h1>
<h2>Step 1：初始設定上限</h2>
依照 Wiki 的範例對照，我們設定了最大上限為 4，尚未塞入任何資料，初始結構如下：
<br/>目標依序放入 A B C D E C D B
<br/>為了說明清楚，Value 與 Key 都會用相同的英文字母表示
<br/> <img src="/assets/image/Algorithm/Cache/MRU/002.png" width="50%" height="50%">
<br/><br/>

<h2>Step 2：新增值 SET - (A, A)</h2>
添加值 KEY = A ; Value = A
<br/> <img src="/assets/image/Algorithm/Cache/MRU/003.png" width="50%" height="50%">
<br/><br/>

<h2>Step 3：新增值 SET - (B, B)</h2>
添加值 KEY = B ; Value = B
<br/>這時 LinkedList 表的權重最低(優先刪除) B > A
<br/> <img src="/assets/image/Algorithm/Cache/MRU/004.png" width="50%" height="50%">
<br/><br/>

<h2>Step 4：新增值 SET - (C, C)</h2>
添加值 KEY = C ; Value = C
<br/>這時 LinkedList 表的權重最低(優先刪除) C > B > A
<br/> <img src="/assets/image/Algorithm/Cache/MRU/005.png" width="50%" height="50%">
<br/><br/>

<h2>Step 5：新增值 SET - (D, D)</h2>
添加值 KEY = D ; Value = D
<br/>這時 LinkedList 表的權重最低(優先刪除) D > C > B > A
<br/> <img src="/assets/image/Algorithm/Cache/MRU/006.png" width="50%" height="50%">
<br/><br/>

<h2>Step 6：新增值 SET - (E, E)</h2>
添加值 KEY = E ; Value = E
<br/>因為 D 最近使用，權重最低因此被刪除
<br/>這時 LinkedList 表的權重最低(優先刪除) E > C > B > A
<br/> <img src="/assets/image/Algorithm/Cache/MRU/007.png" width="50%" height="50%">
<br/><br/>

<h2>Step 7：新增值 SET - (C, C)</h2>
添加值 KEY = C ; Value = C ， C 雖然已存在，但仍要刷新權重
<br/>這時 LinkedList 表的權重最低(優先刪除) C > E > B > A
<br/> <img src="/assets/image/Algorithm/Cache/MRU/008.png" width="50%" height="50%">
<br/><br/>

<h2>Step 8：新增值 SET - (D, D)</h2>
添加值 KEY = D ; Value = D
<br/>因為 C 最近使用，權重最低因此被刪除
<br/>這時 LinkedList 表的權重最低(優先刪除) D > E > B > A
<br/> <img src="/assets/image/Algorithm/Cache/MRU/009.png" width="50%" height="50%">
<br/><br/>

<h2>Step 9：新增值 SET - (B, B)</h2>
添加值 KEY = B ; Value = B ， B 雖然已存在，但仍要刷新權重
<br/>這時 LinkedList 表的權重最低(優先刪除) B > D > E > A
<br/>最終符合 Wiki 上的 MRU 快取策略
<br/> <img src="/assets/image/Algorithm/Cache/MRU/010.png" width="50%" height="50%">
<br/><br/>





<br/><br/>
<h1>第四部分：補充說明</h1>
<h2>Step 1：補充 - MRU 與 Stack 實質上的不同</h2>
<br/> <img src="/assets/image/Algorithm/Cache/MRU/XXX.png" width="50%" height="50%">
<br/><br/>

<h2>Step 2：補充 - LRU 與 MRU 對比</h2>
<br/> <img src="/assets/image/Algorithm/Cache/MRU/XXX.png" width="50%" height="50%">


| 行為             | LRU     | MRU              |
| -------------- | ------- | ---------------- |
| 淘汰策略           | 過久沒用的先丟 | 最新使用的先丟          |
| 類比             | 冰箱裡食材要丟 | 最近看的影片被先移除記錄     |
| 瀏覽器上一頁         | ❌ 不符合   | ✔ 完全符合           |
| 瀏覽器歷史          | ❌ 不符合   | ✔ 是個 Stack / MRU |
| Cache          | ✔ 常用    | ❌ 很少用            |
| Undo / History | ❌ 不是    | ✔ 正確             |


<br/><br/>

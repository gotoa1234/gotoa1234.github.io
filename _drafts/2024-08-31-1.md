---
layout: default_post
title:  "0005. 字典樹(前綴樹) - 字串搜尋演算法 (Trie Algorithm) - 字串搜尋"
excerpt: "演算法-字串搜尋"
tags: Algorithm StringSearching 
---
<div class="summary">
<br/>m：找尋字串總長度 ; n：文本總長度 ; 
<br/>時間複雜度(Time Complex)：O(n)
<br/>空間複雜度： O(n)
<br/>範例檔案：<a href="https://github.com/gotoa1234/Algorithm_StringSearch/tree/main/Algorithm_StringSearch">Source Code</a>
<br/>範例專案：<a href="https://github.com/gotoa1234/Algorithm_StringSearch.git">Code Project</a>
<br/>基本介紹：本篇分為3大部分。
<br/>第一部分：字典樹(前綴樹)演算法 - 介紹
<br/>第二部分：字典樹(前綴樹)演算法 - 實現
<br/>第三部分：字典樹(前綴樹)演算法 - 圖解
</div>

<div class="title">
    <br/><hr class="titleinner">
	<span></span>
	<hr class="titleinner"><br/>
</div>


<br/><br/>
<h1>第一部分：字典樹(前綴樹)演算法 - 介紹</h1>
<h2>Step 1：簡介</h2>
以下截取於<a href="https://zh.wikipedia.org/zh-tw/Trie">Wiki</a>

``` Markdown
在電腦科學中，trie，又稱字首樹或字典樹，是一種有序樹，用於儲存關聯陣列，其中的鍵通常是字串。
與二元搜尋樹不同，鍵不是直接儲存在節點中，而是由節點在樹中的位置決定。
一個節點的所有子孫都有相同的字首，也就是這個節點對應的字串，而根節點對應空字串。
一般情況下，不是所有的節點都有對應的值，只有葉子節點和部分內部節點所對應的鍵才有相關的值。
```

<br/>簡言之，搜尋一串字串(文本)，用此演算法適合找相關聯前綴匹配的應用場景()
<br/>※來源：Wiki
<br/><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/7e/Comparison_computational_complexity.svg/1024px-Comparison_computational_complexity.svg.png" width="100%" height="100%" />
<br/><br/>

<h2>Step 2：優缺點</h2>
優點具有以下：

{:class="table table-bordered"}
| 1. Hash插入字典，效率高  | ： | 高效的前綴搜索和插入操作。 | 
| 2. 查詢效率高  | ： | 能夠處理大量單詞，適合需要快速搜索和頻繁插入新單詞的應用。 | 

<br/>缺點：

{:class="table table-bordered"}
| 1. 預處理開銷大  | ： | 空間效率較低，特別是當字母表很大時。 | 
| 2. 不適用單項查詢  | ： | 不適合處理單個長文本的模式匹配，因為構建字典樹的初始成本較高。 | 

<br/><br/>

<h2>Step 3：預處理樹 - 說明</h2>

<br/>以下出自 Wiki ：

``` markdown
一個儲存了8個鍵的trie結構，"A", "to", "tea", "ted", "ten", "i", "in", "inn".
```

<br/>要先將文本建構成樹，查詢時再遍歷此樹，因此可實現相匹配接近的字串
<br/><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/be/Trie_example.svg/300px-Trie_example.svg.png?20211008170627" />
<br/><br/>



<h1>第二部分：字典樹(前綴樹)演算法 - 實現</h1>
<h2>Step 1：建構式 - 進入</h2>
為了便於解釋演算法流程，這篇範例只說明使用[壞字符表]如何實現，由建構式開始

``` C#
public BadCharacterExample(string text, string pattern)
{
    Console.WriteLine("1. 第一種方式：壞字符表");
    Search(text, pattern);
    Console.WriteLine();
    Console.WriteLine();
}
```

<br/> <img src="/assets/image/Algorithm/StringSearch/BoyerMoore/BoyerMoore_BadChar_Full.png" >
<br/><br/>



<h1>第三部分：字典樹(前綴樹)演算法 - 圖解</h1>
<h2>Step 1：建構式 - 進入</h2>
為了便於解釋演算法流程，這篇範例只說明使用[好後綴表]如何實現，由建構式開始

``` C#
public GoodSuffixExample(string text, string pattern)
{
    Console.WriteLine("2. 第二種方式：好後綴表");
    Search(text, pattern);
    Console.WriteLine();
    Console.WriteLine();
}
```

<br/><br/>

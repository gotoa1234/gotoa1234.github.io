---
layout: default_post
title: "0004. 康威生命遊戲(Game Of Life) 利用 GPU 優化細胞生成 - CPU vs GPU 優化效能說明"
excerpt: "效能議題"
tags:   
- "C#"      
- "Asp.NET Core"
- "Windows Forms"
---

<div class="summary">
<br/>應用所需：1. 顯示卡 (本篇範例 Nvdia 2060 12G)
<br/>&emsp;&emsp;&emsp;&emsp;&emsp;2. Visual Studio 2022 Asp.net Core
<br/>&emsp;&emsp;&emsp;&emsp;&emsp;3. 引用 ILGPU C# 套件實作 GPU 平行運算
<br/>範例檔案：<a href="https://github.com/gotoa1234/MyBlogExample/tree/main/GameOfLifeExample">本篇範例代碼</a>
<br/>相關參考：<a href="https://gotoa1234.github.io/2025/06/21/1.html">0008. 康威生命遊戲(Game Of Life) - 細胞自動機模擬與程序化生成</a>
<br/>探討問題：CPU 適合控制邏輯與少量運算；GPU 擅長大規模資料的平行處理。比較 2 者在康威生命遊戲的執行下效能差異。
<br/>基本介紹：本篇分為三大部分。
<br/>第一部分：定義目標與範圍
<br/>第二部分：測試範例代碼
<br/>第三部分：執行測試
<br/>第四部分：分析結果 & 結論

</div>

<div class="title">
    <br/><hr class="titleinner">
	<span></span>
	<hr class="titleinner"><br/>
</div>


<br/><br/>
<h1>第一部分：定義目標與範圍</h1>

<h2>Step 1：測試目標</h2>
細胞由小而大，當細胞量大時運行處理效率提升比較，並且以 600 世代，CPU 與 GPU 的耗費時間多久才能完成
<br/>※每秒最快執行 10 次 0.1 秒觸發一次世代更新

{:class="table table-bordered"}
| 像素  | 細胞數量 | 計算時間 |
| 512 * 512 | 262,144 | 600 次 |
| 1024 * 1024 | 1,048,576 | 600 次 |
| 2048 * 2048 | 4,194,304 | 600 次 |
| 4096 * 4096 | 16,777,216 | 600 次 |

<br/><br/>


<h2>Step 2：效能比較指標(硬體配置)</h2>
以下是測試用的電腦

{:class="table table-bordered"}
| 1. CPU 與核心數 | ： |  |
| 2. GPU 與顯示卡 | ： | RTX 2060 supper 12G |
| 3. 記憶體 | ： | 32 GB |
| 4. 作業系統版本 | ： | Windows 10 Profession |
| 5. 運算時間 | ： | 每 100 Tric 觸發一次 (每秒10次)，並且觸發 600 次就停止 |
| 6. ILGPU 版本  | ： | 1.5.2 |
| 7. C# 版本 | ： | 8.0 |

<br/> <img src="/assets/image/PerformanceIssue/2025_06_28/xxx.png" alt="' width="50%" height="50%" />
<br/><br/>

<h2>Step 3：執行測試與數據收集</h2>
基本測試方針：

{:class="table table-bordered"}
| 1. 多次測試 | ： | 對每種方法執行至少 5 次測試，取平均值以減少偶然誤差。 |
| 2. 記錄時間 | ： | 除了總耗費時間外，還可以記錄每個操作的平均耗時和最大耗時，並且各執行 5 次 |
| 3. 硬體設備 | ： | 所有測試都使用相同配備。 |
| 4. 相同次數 | ： | 600 次生命週期，每秒最多觸發 10 次 |

<br/><br/>



<br/><br/>
<h1>第二部分：測試範例代碼 </h1>

<h2>Step 1：CPU 範例代碼 </h2>
CPU 的代碼，可參考<a href="https://gotoa1234.github.io/2025/06/21/1.html">0008. 康威生命遊戲(Game Of Life) - 細胞自動機模擬與程序化生成</a>
<br/>調整後的代碼在啟動時會有選項
<br/> <img src="/assets/image/PerformanceIssue/2025_06_28/003.png" alt="' width="20%" height="20%" />
<br/><br/>

<h2>Step 2：GPU 範例代碼 - 使用 ILGPU</h2>
GPU 的代碼也調整於此<a href="https://github.com/gotoa1234/MyBlogExample/tree/main/GameOfLifeExample">範例代碼</a>中
<br/>在 Nuget 中引用 **ILGPU**
<br/> <img src="/assets/image/PerformanceIssue/2025_06_28/004.png" alt="' width="50%" height="50%" />
<br/><br/>


<h2>Step 3：GPU 範例代碼 - 使用方法</h2>
專案中的 3-4. 啟動代碼時，會先判斷有無顯卡，若有才允許使用平行運算
<br/>並且在 3-5. 步驟時會設定使用 **GpuKernel** 方法

``` C#
// 3-4. 初始化 ILGPU
context = Context.CreateDefault();            
try
{
    // GPU
    accelerator = context.CreateCudaAccelerator(0);//電腦沒有顯示卡，此行會報錯          
}
catch
{
    // CPU
    accelerator = context.CreateCPUAccelerator(0);
}
// 3-5. 設定 kernel 方法
kernel = accelerator.LoadAutoGroupedStreamKernel<Index2D, ArrayView2D<byte, Stride2D.DenseX>, ArrayView2D<byte, Stride2D.DenseX>>(GpuKernel);
```

<br/><br/>


<h2>Step 4：GPU 範例代碼 - GpuKernel 平行運算方法 </h2>
實際上的 GpuKernel 就是康威生命遊戲的規則

``` C#
/// <summary>
/// 5. GPU 核心程式 - 康威生命遊戲的規則 與 3-5 , 4-2 相互關聯
/// </summary>        
static void GpuKernel(Index2D index, ArrayView2D<byte, Stride2D.DenseX> current, ArrayView2D<byte, Stride2D.DenseX> next)
{
    // 5-1. Game of Life 計算
    // 備註: xAxis, yAxis 代表細胞座標
    // 備註: gridX, gridY 代表鄰居偏移量
    int x = index.X;
    int y = index.Y;
    int width = current.IntExtent.X;
    int height = current.IntExtent.Y;
    // 5-2. 計算鄰居數量
    int count = 0;
    for (int yAxis = -1; yAxis <= 1; yAxis++)
    {
        for (int xAxis = -1; xAxis <= 1; xAxis++)
        {
            if (xAxis == 0 && yAxis == 0) continue;
            // 處理邊界（環繞）
            int nx = (x + xAxis + width) % width;
            int ny = (y + yAxis + height) % height;
            count += current[new Index2D(nx, ny)];
        }
    }
    byte alive = current[index];
    // 5-3. Game of Life 規則
    if (alive == 1 && (count < 2 || count > 3))
        next[index] = 0; // 死亡
    else if (alive == 0 && count == 3)
        next[index] = 1; // 誕生
    else
        next[index] = alive; // 保持原狀
}
```

<br/><br/>

<h2>Step 5：GPU 範例代碼 - GpuKernel 呼叫時機點</h2>
在 4-2. 時( Timer 中) 才會真正執行 GPU 的平行運算處理

``` C#
// 4-2. 執行 kernel - 傳遞 View 給 kernel (在步驟 3-5. 宣告方法)
kernel(new Index2D(WidthCells, HeightCells), bufferCurrent.View, bufferNext.View);

```

<br/><br/>





<br/><br/>
<h1>第三部分：執行測試 </h1>

<h2>Step 1：執行測試 512 * 512 </h2>

<br/> 5 次執行結果如下

{:class="table table-bordered"}
| 1. | 耗費：12.7598317 秒 | 
| 2. | 耗費：13.2819952 秒 | 
| 3. | 耗費：18.2613657 秒 | 
| 4. | 耗費：15.2953010 秒 | 
| 5. | 耗費：12.9500915 秒 | 


<br/> <img src="/assets/image/PerformanceIssue/2024_11_16/004.png" width="50%" height="50%" />
<br/><br/>

<h2>Step 2：執行測試 1024 * 1024 </h2>

<br/> <img src="/assets/image/PerformanceIssue/2024_11_16/004.png" width="50%" height="50%" />
<br/><br/>


<h2>Step 3：執行測試 2048 * 2048 </h2>

<br/><br/>

<h2>Step 4：執行測試 4096 * 4096</h2>

<br/><br/>






<br/><br/>
<h1>第四部分：分析結果 & 結論</h1>

<h2>Step 1：重複 5 次執行測試 - 總計</h2>
總耗時間與補充備註：

{:class="table table-bordered"}
| 執行細胞數量 | CPU 5次總耗時（秒） | GPU 5次總耗時 |
| --- | --- | --- |
| 512 * 512 | 65.78 秒 | 使用管道技術，減少網路往返 |
| 1024 * 1024 | 120.92 秒 | 增加數據壓縮，減少傳輸量，壓縮時間列入計算 | 
| 2048 * 2048 | 66.99 秒 | 使用二進制序列化，效能較差 | 
| 4096 * 4096 | 66.99 秒 | 使用二進制序列化，效能較差 | 


<br/><br/>


<h2>Step 2：重複 5 次執行測試 - 範圍區間</h2>
每種方法的**平均、最大、最小**耗時時間：

{:class="table table-bordered"}
| 方法名稱 | CPU 平均耗費時間（秒） | CPU 最大耗費時間（秒） | CPU 最小耗費時間（秒） |
| --- | --- | --- |
| 512 * 512 | 65.78 秒 | 使用管道技術，減少網路往返 |
| 1024 * 1024 | 120.92 秒 | 增加數據壓縮，減少傳輸量，壓縮時間列入計算 | 
| 2048 * 2048 | 66.99 秒 | 使用二進制序列化，效能較差 | 
| 4096 * 4096 | 66.99 秒 | 使用二進制序列化，效能較差 | 

{:class="table table-bordered"}
| 方法名稱 | GPU 平均耗費時間（秒） | GPU 最大耗費時間（秒） | GPU 最小耗費時間（秒） |
| --- | --- | --- |
| 512 * 512 | 65.78 秒 | 使用管道技術，減少網路往返 |
| 1024 * 1024 | 120.92 秒 | 增加數據壓縮，減少傳輸量，壓縮時間列入計算 | 
| 2048 * 2048 | 66.99 秒 | 使用二進制序列化，效能較差 | 
| 4096 * 4096 | 66.99 秒 | 使用二進制序列化，效能較差 | 


<br/><br/>

<h2>Step 3：結論 & 適合場景與分析</h2>

{:class="table table-bordered"}
| 耗時： | 22.87 秒 | 
| 分析： | Lua 腳本批次寫入效能介於壓縮與管道模式之間，因為每批次執行 Lua 需額外的處理(組成文本、記憶體配置)時間。 | 
|       | 具原子性，適合需要高度一致性的場景。

<br/>
<br/><br/>

---
layout: default_post
title: "0008. Docker Container - 零停機部署（Zero-downtime deployment） - 藍綠部署策略"
excerpt: "Docker"
tags: 
- "Docker"
- "Docker-Compose"
- "Container"
- "Ubuntu"
- "Linux"
- "Nginx"
- "Jenkins"
- "Continuous Integration(CI)"
- "Continuous Deployment(CD)"
- "Redis"
- "StackExchangeRedis"
- "SignalR"
---

<div class="summary">
<br/>解決問題：部署 Docker Container 時，會先將舊的移除，然後再運行新的 Container 這時雖然只有短短幾秒，但是用戶畫面已經錯誤了
<br/>基本介紹：本篇分為 4 部分。
<br/>第一部分：問題描述 & 說明
<br/>第二部分：基礎架構 & 藍綠部署策略
<br/>第三部分：實作調整方式
<br/>第四部分：DEMO 驗證成果
</div>

<div class="title">
    <br/><hr class="titleinner">
	<span></span>
	<hr class="titleinner"><br/>
</div>

<br/><br/>

<h1>第一部分：問題描述 & 說明</h1>
<h2>Step 1：檢查 Ubuntu 主機版本</h2>
如圖，當主機非 LTS 版本時
<br/> <img src="/assets/image/ContinuousDeployment/docker/2025_03_01/001.png" alt="" width="50%" height="50%" />
<br/>









<h1>第二部分：基礎架構 & 藍綠部署策略</h1>
<h2>Step 1：檢查 Ubuntu 主機版本</h2>
如圖，當主機非 LTS 版本時
<br/> <img src="/assets/image/ContinuousDeployment/docker/2025_03_01/001.png" alt="" width="50%" height="50%" />
<br/>

<h2>Step x：藍綠部署遭遇問題</h2>

``` markdown
用戶可能會遇到以下幾種問題：

1. 會話 (Session) 丟失：

csharpCopy// 如果使用了內存中的會話存儲，當容器切換時會話會丟失
// 用戶可能需要重新登入，或者丟失購物車等會話數據
解決方案：
csharpCopy// 使用 Redis 來存儲會話
public void ConfigureServices(IServiceCollection services)
{
    services.AddStackExchangeRedisCache(options =>
    {
        options.Configuration = "localhost:6379";
    });

    services.AddSession(options =>
    {
        options.Cookie.IsEssential = true;
    });
}

2. 正在處理中的請求中斷：


表單提交可能失敗
文件上傳可能中斷
API 調用可能返回錯誤

解決方案：
Nginx 配置，ServerB, ServerC 有以下 Nginx 設置，並且用 Jenkins 建置腳本切換(需搭配健康檢查)
Server B 的 Nginx 調整成以下：

upstream backend {
    server localhost:8080;        # Server B 自己的服務(藍/綠)
	server localhost:8082;        # Server B 自己的服務(藍/綠)
    server serverC_ip:8080;      # Server C 的服務
}

server {
    listen 80;
    server_name your-domain.com;

    location / {
        proxy_pass http://backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
}


Server C 的 Nginx 調整成以下：

upstream backend {
    server serverB_ip:8080;      # Server B 的服務
    server localhost:8080;        # Server C 自己的服務(藍/綠)
	server localhost:8082;        # Server C 自己的服務(藍/綠)
}

server {
    listen 80;
    server_name your-domain.com;

    location / {
        proxy_pass http://backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
}

3. SignalR 連接問題：

csharpCopy// 使用 Redis 作為 SignalR 的背板
services.AddSignalR().AddStackExchangeRedis("localhost:6379");
建議的完整解決方案：

使用 Sticky Session：

nginxCopyupstream backend {
    ip_hash;  # 確保同一用戶始終訪問同一服務器
    server localhost:8080;
    server localhost:8082;
}

實現優雅關閉：

csharpCopypublic class Startup
{
    public void Configure(IApplicationBuilder app, IHostApplicationLifetime lifetime)
    {
        lifetime.ApplicationStopping.Register(() =>
        {
            // 等待現有請求處理完成
            Thread.Sleep(TimeSpan.FromSeconds(30));
        });
    }
}

添加重試機制：

javascriptCopy// 在前端添加請求重試邏輯
async function fetchWithRetry(url, options = {}, retries = 3) {
    for (let i = 0; i < retries; i++) {
        try {
            const response = await fetch(url, options);
            if (response.ok) return response;
        } catch (err) {
            if (i === retries - 1) throw err;
            await new Promise(resolve => setTimeout(resolve, 1000));
        }
    }
}

4. 實現健康檢查：

csharpCopypublic void ConfigureServices(IServiceCollection services)
{
    services.AddHealthChecks()
        .AddRedis("localhost:6379")
        .AddDbContextCheck<ApplicationDbContext>();
}
如果正確實施以上解決方案，用戶基本上不會感知到切換過程。但建議在以下時間進行部署：
在藍綠部署時，可以確保新容器確實能正常運作

非峰值時段
用戶活動較少的時間
避免在重要業務處理時間

另外，建議實施監控：
csharpCopy// 添加請求追踪
app.Use(async (context, next) =>
{
    var correlationId = context.Request.Headers["X-Correlation-ID"].FirstOrDefault() 
        ?? Guid.NewGuid().ToString();
    
    using (LogContext.PushProperty("CorrelationId", correlationId))
    {
        await next();
    }
});
這樣可以及時發現和解決切換過程中的問題。 CopyRetry
        
            
           
```

{:class="table table-bordered"}
| 階段 | 說明 |
| --- | --- |
| 1. 會話 (Session) 丟失： | 1-1. 開始持續整合，首先拉取代碼   |
|               | 1-2. 其次建立專案 & Publish 出部署檔案   |
|               | 1-3. 最後封裝成 Docker Image  |
| 2. 上傳 Image | 將 Jenkins 機器上建立的 Docker Image 上傳到 Harbar 或 DockerHub 上 |
| 3. 下載 Image | 依照 Jenkins 上的 Pipeline 腳本，到指定的機器 |
| 4. Jenkins CD | 4-1. 開始持續部署，被指定的機器會開始 拉取 Docker Image   |
|               | 4-2. 執行 Docker Run 建立 Container 完成部署   |

<br/> <img src="/assets/image/ContinuousDeployment/docker/2025_03_01/001.png" alt="" width="50%" height="50%" />
<br/>











<h1>第三部分：實作調整方式</h1>
<h2>Step 1：檢查 Ubuntu 主機版本</h2>
如圖，當主機非 LTS 版本時
<br/> <img src="/assets/image/ContinuousDeployment/docker/2025_03_01/001.png" alt="" width="50%" height="50%" />
<br/>









<h1>第四部分：DEMO 驗證成果</h1>
<h2>Step 1：檢查 Ubuntu 主機版本</h2>
如圖，當主機非 LTS 版本時
<br/> <img src="/assets/image/ContinuousDeployment/docker/2025_03_01/001.png" alt="" width="50%" height="50%" />
<br/>

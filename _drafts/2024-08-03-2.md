---
layout: default_post
title:  "0002. å…‹åŠªæ–¯-è«é‡Œæ–¯-æ™®æ‹‰ç‰¹ - å­—ä¸²æœå°‹æ¼”ç®—æ³• (Knuthâ€“Morrisâ€“Pratt Algorithm, KMP) - å­—ä¸²æœå°‹"
excerpt: "æ¼”ç®—æ³•-å­—ä¸²æœå°‹"
tags: Algorithm StringSearching 
---
<div class="summary">
<br/>mï¼šæ–‡æœ¬ç¸½é•·åº¦ ; nï¼šæ‰¾å°‹å­—ä¸²ç¸½é•·åº¦
<br/>æ™‚é–“è¤‡é›œåº¦(Time Complex)ï¼šO(m + n)
<br/>æœ€ä½³æ™‚é–“ï¼š O(m) 
<br/>æœ€å£æ™‚é–“ï¼š O(m + n)
<br/>ç©ºé–“è¤‡é›œåº¦ï¼š O(n)
<br/>ç¯„ä¾‹æª”æ¡ˆï¼š<a href="https://github.com/gotoa1234/Algorithm_StringSearch/tree/main/Algorithm_StringSearch">Source Code</a>
<br/>ç¯„ä¾‹å°ˆæ¡ˆï¼š<a href="https://github.com/gotoa1234/Algorithm_StringSearch.git">Code Project</a>
<br/>åŸºæœ¬ä»‹ç´¹ï¼šæœ¬ç¯‡åˆ†ç‚º3å¤§éƒ¨åˆ†ã€‚
<br/>ç¬¬ä¸€éƒ¨åˆ†ï¼šKMPæ¼”ç®—æ³• - ä»‹ç´¹
<br/>ç¬¬äºŒéƒ¨åˆ†ï¼šKMPæ¼”ç®—æ³• - ä»£ç¢¼
<br/>ç¬¬ä¸‰éƒ¨åˆ†ï¼šKMPæ¼”ç®—æ³• - åœ–è§£èªªæ˜
</div>

<div class="title">
    <br/><hr class="titleinner">
	<span></span>
	<hr class="titleinner"><br/>
</div>


<br/><br/>
<h1>ç¬¬ä¸€éƒ¨åˆ†ï¼šKMPæ¼”ç®—æ³• - ä»‹ç´¹</h1>
<h2>Step 1ï¼šç°¡ä»‹</h2>
ä»¥ä¸‹æˆªå–æ–¼<a href="https://zh.wikipedia.org/zh-tw/KMP%E7%AE%97%E6%B3%95">Wiki</a>

``` Markdown
åœ¨é›»è…¦ç§‘å­¸ä¸­ï¼Œå…‹åŠªæ–¯-è«é‡Œæ–¯-æ™®æ‹‰ç‰¹å­—ä¸²å°‹æ‰¾æ¼”ç®—æ³•ï¼ˆè‹±èªï¼šKnuthâ€“Morrisâ€“Pratt algorithmï¼Œç°¡ç¨±ç‚ºKMPæ¼”ç®—æ³•ï¼‰å¯åœ¨ä¸€å€‹å­—ä¸²Så…§å°‹æ‰¾ä¸€å€‹å­—Wçš„å‡ºç¾ä½ç½®ã€‚
ä¸€å€‹è©åœ¨ä¸åŒ¹é…æ™‚æœ¬èº«å°±åŒ…å«è¶³å¤ çš„è³‡è¨Šä¾†ç¢ºå®šä¸‹ä¸€å€‹åŒ¹é…å¯èƒ½çš„é–‹å§‹ä½ç½®ï¼Œæ­¤æ¼”ç®—æ³•åˆ©ç”¨é€™ä¸€ç‰¹æ€§ä»¥é¿å…é‡æ–°æª¢æŸ¥å…ˆå‰é…å°çš„å­—å…ƒã€‚

é€™å€‹æ¼”ç®—æ³•ç”±é«˜å¾·ç´å’Œæ²ƒæ©Â·æ™®æ‹‰ç‰¹åœ¨1974å¹´æ§‹æ€ï¼ŒåŒå¹´è©¹å§†æ–¯Â·HÂ·è«é‡Œæ–¯ä¹Ÿç¨ç«‹åœ°è¨­è¨ˆå‡ºè©²æ¼”ç®—æ³•ï¼Œæœ€çµ‚ä¸‰äººæ–¼1977å¹´è¯åˆç™¼è¡¨ã€‚
```

<br/>ç°¡è¨€ä¹‹ï¼Œæœå°‹ä¸€ä¸²å­—ä¸²(æ–‡æœ¬)ï¼Œç”¨æ­¤æ¼”ç®—æ³•æœ€ä½³ & æœ€å£è¡¨ç¾éƒ½ç¶­æŒåœ¨ç·šæ€§æ™‚é–“è¤‡é›œåº¦
<br/>â€»ä¾†æºï¼šWiki
<br/><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/7e/Comparison_computational_complexity.svg/1024px-Comparison_computational_complexity.svg.png" width="100%" height="100%" />
<br/><br/>

<h2>Step 2ï¼šå„ªç¼ºé»</h2>
å„ªé»å…·æœ‰ä»¥ä¸‹ï¼š

{:class="table table-bordered"}
| 1. é«˜æ•ˆç‡  | ï¼š | KMPæ¼”ç®—æ³•çš„æ™‚é–“è¤‡é›œåº¦æœ€å£æ˜¯ ğ‘‚(ğ‘›+ğ‘š)ï¼Œæœ€å¥½å¯ä»¥åˆ° ğ‘‚(ğ‘š) è¡¨ç¤ºæ°¸é éƒ½åœ¨ç·šæ€§æ™‚é–“å…§ | 
| 2. é¿å…å¤šé¤˜çš„æ¯”è¼ƒ  | ï¼š | å»ºç«‹åŒ¹é…è¡¨å¾Œï¼Œå¯ä»¥è·³éé‡è¤‡çš„æ¯”å°ï¼Œé¿å…ç™¼ç”Ÿæš´åŠ›æœå°‹æ³•ä¸å¿…è¦çš„é–‹éŠ· | 

<br/>ç¼ºé»ï¼š

{:class="table table-bordered"}
| 1. é¡å¤–ç©ºé–“é–‹éŠ·  | ï¼š | éœ€è¦é¡å¤–çš„ ğ‘‚(ğ‘›) çš„æŸ¥æ‰¾ç›®æ¨™å­—ä¸²çš„ç©ºé–“ï¼Œä¾†ç”¢ç”ŸåŒ¹é…è¡¨ï¼Œåœ¨è¨˜æ†¶é«”ç¨€ç¼ºçš„ç‹€æ³ä¸‹ä¸å»ºè­°ä½¿ç”¨ (åµŒå…¥å¼è¨­å‚™ EX:æ‰‹éŒ¶)  | 
| 2. è¤‡é›œåº¦é«˜  | ï¼š | èˆ‡å…¶ä»–ç®—æ³•ç›¸æ¯”ï¼Œæ­¤ç®—æ³•çš„å¯¦ç¾è¤‡é›œåº¦è¼ƒé«˜ï¼Œè¦æœ‰ä¸€å®šçš„ç†è§£æ‰èƒ½æ˜ç™½åŒ¹é…è¡¨è·³éæ©Ÿåˆ¶ | 
| 3. ç‰¹æ®Šå­—ç¬¦é¡å¤–é–‹éŠ·  | ï¼š | å› ç‚ºé¡å¤–çš„  ğ‘‚(ğ‘›) åŒ¹é…è¡¨ï¼Œè‹¥æ˜¯æœ‰ä¸­æ–‡ä¿å­˜çš„å°‡æœƒæ˜¯ UTF-8 / UTF-16 / UTF-32 (è‡³å°‘é¡å¤– 4 Bytes)...  |

<br/><br/>

<h2>Step 3ï¼šæœ¬ç¯‡2ç¨®ç®—æ³• - æ—‹è½‰å“ˆå¸Œ & æ‹‰è³“æŒ‡ç´‹</h2>
æ‹‰è³“å¡æ™®æ¼”ç®—æ³• + æ—‹è½‰å“ˆå¸Œ é©åˆç”¨æ–¼å¿«é€Ÿç†è§£é€™å€‹æ¼”ç®—æ³•çš„æœ¬è³ª
<br/>æ‹‰è³“å¡æ™®æ¼”ç®—æ³• + æ‹‰è³“æŒ‡ç´‹ï¼Œå‰‡æ˜¯å¤§å¹…åº¦çš„è®“é€™å€‹æ¼”ç®—æ³•çš„æ™‚é–“è¤‡é›œåº¦åœ¨é€šå¸¸æƒ…æ³ä¸‹æ¥è¿‘ç·šæ€§æ™‚é–“ã€‚
<br/>â€»ç¢°æ’æ„ˆå°‘æ„ˆèƒ½é”åˆ° O(m + n) ; åä¹‹ç¢°æ’æ„ˆå¤šå‰‡æœƒåˆ° O(m * n) 

{:class="table table-bordered"}
| ç‰¹æ€§ | æ—‹è½‰å“ˆå¸Œ | æ‹‰è³“æŒ‡ç´‹ |
| --- | --- | --- |
| 1. ç¢°æ’ç‡  | é«˜ | ä½ | 
| 2. å¯¦ç¾è¤‡é›œåº¦  | ä½ | é«˜ | 
| 3. é©ç”¨ç¯„åœ  | ç’°å½¢æ•¸çµ„æˆ–å­—ç¬¦ä¸² | å„ç¨®å­—ç¬¦ä¸²åŒ¹é…å•é¡Œ | 
| 4. è¨ˆç®—æ•ˆç‡  | æ›´æ–°ç°¡å–®ï¼Œä½†ç¢°æ’ç‡é«˜ | æ»¾å‹•å“ˆå¸Œæ•ˆç‡é«˜ï¼Œè¨ˆç®—è¤‡é›œ | 
| 5. ä¾è³´è³ªæ•¸é¸æ“‡  | ä¸ä¾è³´ | ä¾è³´ | 
 
<br/><br/>

<h1>ç¬¬äºŒéƒ¨åˆ†ï¼šæ—‹è½‰å“ˆå¸Œ - ä»£ç¢¼</h1>
<h2>Step 1ï¼šå»ºæ§‹å¼ - é€²å…¥</h2>

``` C#
/// <summary>
/// å»ºæ§‹å¼
/// </summary>
/// <param name="text">åŸå§‹è³‡æ–™</param>
/// <param name="pattern">æŸ¥è©¢çš„å­—ä¸²</param>
public Method_RollingHash(string text, string pattern)
{
    int result = RabinKarpSearch(text, pattern);

    if (result != -1)
    {
        Console.WriteLine($"Pattern found at index {result}");
    }
    else
    {
        Console.WriteLine("Pattern not found");
    }
}
```

<br/><br/>

<h2>Step 2ï¼šä¸»ç¨‹å¼ </h2>
ä¸»ç¨‹å¼åŒ…å«äº† 5 å¤§éƒ¨åˆ†ï¼Œæ¯æ¬¡æ²’æœ‰æ¯”å°åˆ°å¾Œç”¨ æ—‹è½‰å“ˆå¸Œ (Rolling Hashes) ç”¢ç”Ÿä¸‹ä¸€å€‹å“ˆå¸Œå€¼ï¼Œç¹¼çºŒæ¯”å°ã€‚

``` C#
/// <summary>
/// æ‹‰è³“å¡æ™®æœç´¢ç®—æ³• - æ—‹è½‰å“ˆå¸Œ (Rabin-Karp Algorithm)
/// </summary>
/// <param name="text">åŸå§‹è³‡æ–™</param>
/// <param name="pattern">æŸ¥è©¢çš„å­—ä¸²</param>
/// <returns></returns>
private int RabinKarpSearch(string text, string pattern)
{
    // 1. é è™•ç†ï¼šè¨ˆç®—æ–‡å­—å’ŒæŸ¥è©¢å°è±¡çš„ Hash
    int textLength = text.Length;
    int targetLength = pattern.Length;
    int patternHash = CalculateRollingHash(pattern, 0, targetLength);
    int textHash = CalculateRollingHash(text, 0, targetLength);

    // 2. æ»‘å‹•çª—å£è™•ç† â€»æœ€å¤šæ»‘å‹• textLength - targetLength æ¬¡
    for (int index = 0; index <= textLength - targetLength; index++)
    {
        // 3-1. åŒ¹é…ï¼Œå¦‚æœ Hash ç›¸ç­‰ï¼Œå‰‡é€²ä¸€æ­¥æ¯”è¼ƒ
        if (patternHash == textHash)
        {
            int findIndex = 0;
            // 3-2. é€²ä¸€æ­¥æ¯”è¼ƒï¼Œæ¯”å°å­—å…ƒæ˜¯å¦ç›¸ç­‰
            // â€»æ—‹è½‰å“ˆå¸Œæœ‰å¯èƒ½ç¢°æ’ï¼Œæ‰€ä»¥éœ€è¦é€²ä¸€æ­¥æ¯”å° EX: ABCD èˆ‡ DCBA ç›¸åŒ Hash
            for (; findIndex < targetLength; findIndex++)
            {
                if (text[index + findIndex] != pattern[findIndex])
                    break;
            }
            // 4. å¦‚æœå®Œå…¨åŒ¹é…ï¼Œè¿”å›ç´¢å¼•
            if (findIndex == targetLength)
                return index;
        }
        // 3-3. ä¸åŒ¹é…ï¼Œæ›´æ–° Hash å€¼
        if (index < textLength - targetLength)
        {
            textHash = UpdateRollingHash(textHash, text[index], text[index + targetLength]);
        }
    }
    // 5. æ²’æ‰¾åˆ°ï¼Œè¿”å› -1
    return -1;
}

```

<br/><br/>


<h2>Step 3ï¼šå­å‡½æ•¸ - å–å¾—æ–‡æœ¬æŸå€‹å€å¡Šçš„å“ˆå¸Œå€¼</h2>
åœ¨é è™•ç†æ™‚æœƒå°‡æœå°‹ç›®æ¨™ã€æ–‡æœ¬çš„å‰å¹¾å€‹å­—ä¸²(åŸºæ–¼æœå°‹ç›®æ¨™é•·åº¦)ï¼Œç”¢ç”Ÿåˆå§‹å“ˆå¸Œå€¼ã€‚

``` C#
/// <summary>
/// è¨ˆç®— Hash å€¼ (ç´¯åŠ å­—ç¬¦çš„ ASCII å€¼)
/// </summary>
/// <param name="str">å‚³å…¥çš„å­—ä¸²</param>
/// <param name="start">èµ·å§‹ç´¢å¼•</param>
/// <param name="length">ç¸½é•·åº¦</param>
/// <returns></returns>
private int CalculateRollingHash(string str, int start, int length)
{
    int hash = 0;
    for (int index = start; index < start + length; index++)
    {
        hash += str[index]; 
    }
    return hash;
}

```

<br/><br/>

<h2>Step 4ï¼šå­å‡½æ•¸ - æ—‹è½‰å“ˆå¸Œ</h2>
æ²’æ‰¾åˆ°æ™‚ï¼Œå°ä¸‹ä¸€å€‹å­—ç¬¦åšå“ˆå¸Œçš„ç”¢ç”Ÿ
<br/>â€»æ—‹è½‰å“ˆå¸Œ - ç”¨ Ascii ç¢¼åšåŠ æ¸›æ³•é‹ç®—åš Hash å€¼ï¼Œç°¡å–®ï¼Œä½†è¨»å®šæœƒç¢°æ’
<br/>â€»EXï¼š ABC èˆ‡ CBA éƒ½æœƒç¢°æ’åˆ°ç›¸åŒçš„ Ascii åŠ ç¸½å€¼ï¼Œæ¯å¤šä¸€æ¬¡ç¢°æ’ï¼Œå°±æœƒæµªè²»ä¸€æ¬¡æœå°‹æ©Ÿæœƒã€‚

``` C#
/// <summary>
/// æ²’æ‰¾åˆ°æ™‚é€²å…¥ - æ›´æ–°æ—‹è½‰ Hash å€¼ 
/// <para>â€»åªæœ‰ä¸€å€‹å­—å…ƒçš„è®Šå‹•</para>
/// </summary>    
/// <param name="oldHash">ç•¶å‰èˆŠæœ‰çš„ Hash å€¼</param>
/// <param name="oldChar">èˆŠçš„å–®ä¸€å­—å…ƒ</param>
/// <param name="newChar">æ–°çš„å–®ä¸€å­—å…ƒ</param>
/// <returns></returns>
private int UpdateRollingHash(int oldHash, char oldChar, char newChar)
{
    return oldHash - oldChar + newChar;
}
```

<br/><br/>


<h1>ç¬¬ä¸‰éƒ¨åˆ†ï¼šæ—‹è½‰å“ˆå¸Œ - åœ–è§£èªªæ˜</h1>
<h2>Step 1ï¼šåœ–è§£</h2>
<br/> <img src="/assets/image/Algorithm/StringSearch/001.png" width="50%" height="50%" />
<br/><br/>

<h1>ç¬¬å››éƒ¨åˆ†ï¼šæ‹‰è³“æŒ‡ç´‹ - ä»£ç¢¼</h1>
<h2>Step 1ï¼šå»ºæ§‹å¼ - é€²å…¥</h2>

``` C#
/// <summary>
/// å»ºæ§‹å¼
/// </summary>
/// <param name="text">åŸå§‹è³‡æ–™</param>
/// <param name="pattern">æŸ¥è©¢çš„å­—ä¸²</param>
public Method_RabinFingerprint(string text, string pattern)
{
    // ä½¿ç”¨è³ªæ•¸ prime é€²è¡Œæ¨¡é‹ç®—
    int prime = 101; 

    int result = RabinKarpSearch(text, pattern, prime);

    if (result != -1)
    {
        Console.WriteLine($"Pattern found at index {result}");
    }
    else
    {
        Console.WriteLine("Pattern not found");
    }
}
```

<br/><br/>

<h2>Step 2ï¼šä¸»ç¨‹å¼ </h2>
ä¸»ç¨‹å¼åŒ…å«äº† 5 å¤§éƒ¨åˆ†ï¼Œæ¯æ¬¡æ²’æœ‰æ¯”å°åˆ°å¾Œç”¨ æ‹‰è³“æŒ‡ç´‹ (Rabin Finger) ç”¢ç”Ÿä¸‹ä¸€å€‹å“ˆå¸Œå€¼ï¼Œç¹¼çºŒæ¯”å°ã€‚
<br/>å…¶ä¸­ 3-4. æ˜¯æ‹‰è³“æŒ‡ç´‹çš„æ»‘å‹•çª—å£ï¼Œè¨ˆç®—ä¸‹ä¸€å­—ç¬¦çš„æ­£ç¢º Hash æ–¹å¼
<br/>3-5. å› ç‚ºå–é¤˜æ•¸(%)çš„æ–¹å¼ï¼Œå¦‚æœæœ‰å°æ–¼0ï¼ŒåŠ ä¸Šé–‹ç™¼è€…è¨­å®šçš„è³ªæ•¸ (Prime) å¯ä½¿æœŸåˆ°æ­£ç¢ºçš„ Hash æ­£æ•¸ã€‚

``` C#
/// <summary>
/// æ‹‰è³“å¡æ™®æœç´¢ç®—æ³• - æ‹‰è³“æŒ‡ç´‹ (Rabin-Karp Algorithm)
/// </summary>
/// <param name="text">åŸå§‹è³‡æ–™</param>
/// <param name="pattern">æŸ¥è©¢çš„å­—ä¸²</param>
/// <param name="prime">ä½¿ç”¨è‡ªå®šç¾©çš„è³ªæ•¸</param>
/// <returns></returns>
private int RabinKarpSearch(string text, string pattern, int prime)
{
    // 1. é è™•ç†ï¼šè¨ˆç®—æ–‡å­—å’ŒæŸ¥è©¢å°è±¡çš„ Hash
    int textLength = text.Length;
    int targetLength = pattern.Length;
    int patternHash = CalculateRabinFingerprint(pattern, 0, targetLength, prime);
    int textHash = CalculateRabinFingerprint(text, 0, targetLength, prime);

    // 2. æ»‘å‹•çª—å£è™•ç† â€»æœ€å¤šæ»‘å‹• textLength - patternLength æ¬¡
    for (int index = 0; index <= textLength - targetLength; index++)
    {
        // 3-1. åŒ¹é…ï¼Œå¦‚æœ Hash ç›¸ç­‰ï¼Œå‰‡é€²ä¸€æ­¥æ¯”è¼ƒ
        if (patternHash == textHash)
        {
            int findeIndex;
            // 3-2. é€²ä¸€æ­¥æ¯”è¼ƒï¼Œæ¯”å°å­—å…ƒæ˜¯å¦ç›¸ç­‰
            for (findeIndex = 0; findeIndex < targetLength; findeIndex++)
            {
                if (text[index + findeIndex] != pattern[findeIndex])
                    break;
            }
            if (findeIndex == targetLength)
                return index;
        }
        // 3-3. ä¸åŒ¹é…ï¼Œæ›´æ–° Hash å€¼
        if (index < textLength - targetLength)
        {
            // 3-4. æ›´æ–°æ–‡æœ¬çª—å£çš„å“ˆå¸Œå€¼
            // â€» èˆŠHash * åŸºæ•¸(é€™è£¡256) + æ–°å­—ç¬¦ - èˆŠå­—ç¬¦ * [åŸºæ•¸(256)çš„ç›®æ¨™å­—ä¸²é•·åº¦å¹³æ–¹]
            // â€» Base ä¸€å®šè¦é¸æ“‡ç•¶å‰å­—ç¬¦ä¸²å¤§çš„å€¼ï¼Œä¾‹å¦‚ A-Z å…± 26å€‹å­—æ¯ï¼Œå»ºè­°32æˆ–64ï¼Œé¿å… Hash ç¢°æ’
            // â€» æ­¤å¤– Base æ„ˆå°æ•ˆèƒ½æ„ˆä½³ï¼Œä½†ä»¥ç¾ä»£é›»è…¦ä¾†èªªï¼Œå·®ç•°ä¸å¤§
            textHash = (textHash * 256 + 
                        text[index + targetLength] - 
                        text[index] * (int)Math.Pow(256, targetLength)
                       ) % prime;
            // 3-5. è² æ•¸è½‰æ­£
            if (textHash < 0)
                textHash = (textHash + prime);
        }
    }
    // 5. æ²’æ‰¾åˆ°ï¼Œè¿”å› -1
    return -1;
}
```

<br/><br/>


<h2>Step 3ï¼šå­å‡½æ•¸ - æ‹‰è³“æŒ‡ç´‹</h2>
åœ¨é è™•ç†æ™‚æœƒå°‡æœå°‹ç›®æ¨™ã€æ–‡æœ¬çš„å‰å¹¾å€‹å­—ä¸²(åŸºæ–¼æœå°‹ç›®æ¨™é•·åº¦)ï¼Œé€éæ‹‰è³“æŒ‡ç´‹å–é¤˜çš„æ–¹å¼ç”¢ç”Ÿåˆå§‹å“ˆå¸Œå€¼

``` C#
/// <summary>
/// è¨ˆç®—æ‹‰è³“æŒ‡ç´‹
/// </summary>
/// <param name="str">å‚³å…¥çš„å­—ä¸²</param>
/// <param name="start">èµ·å§‹ç´¢å¼•</param>
/// <param name="length">ç¸½é•·åº¦</param>
/// <param name="prime">è³ªæ•¸</param>
/// <return></return>
private int CalculateRabinFingerprint(string str, int start, int length, int prime)
{
    int hash = 0;
    for (int index = start; index < start + length; index++)
    {
        // ä½¿ç”¨åˆé©çš„è³ªæ•¸å–é¤˜æ•¸
        hash = (hash * 256 + str[index]) % prime; 
    }
    return hash;
}

```

<br/><br/>




<h1>ç¬¬äº”éƒ¨åˆ†ï¼šæ‹‰è³“æŒ‡ç´‹ - åœ–è§£èªªæ˜</h1>
<h2>Step 1ï¼šåœ–è§£èªªæ˜</h2>
<br/> <img src="/assets/image/Algorithm/StringSearch/002.png" width="50%" height="50%" />
<br/><br/>

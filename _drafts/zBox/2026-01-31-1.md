---
layout: default_post
title:  "0006. Z 演算法 - 字串搜尋演算法 (Z Algorithm) - 字串搜尋"
excerpt: "演算法-字串搜尋"
tags:
- "Algorithm String Searching"
- "Algorithm"
- "C#"
- "Asp.NET Core"
---
<div class="summary">
<br/>m：找尋字串總長度 ; n：文本總長度 ; 
<br/>時間複雜度(Time Complex)：O(n + m)
<br/>空間複雜度： O(n + m)
<br/>範例檔案：<a href="https://github.com/gotoa1234/LeetCodeProblemSolvingBy_C_Sharp/blob/main/LeetCodePractice/LeetcodePractice/Easy/0796_Prime_Number_of_Set_Bits_in_Binary_Representation.cs">Source Code</a>
<br/>範例專案：<a href="https://github.com/gotoa1234/LeetCodeProblemSolvingBy_C_Sharp.git">Code Project</a>
<br/>基本介紹：本篇分為3大部分。
<br/>第一部分：Z 演算法 - 介紹
<br/>第二部分：Z 演算法 - 實現
<br/>第三部分：Z 演算法 - 圖解
</div>

<div class="title">
    <br/><hr class="titleinner">
	<span></span>
	<hr class="titleinner"><br/>
</div>


<br/><br/>
<h1>第一部分：Z 演算法 - 介紹</h1>
<h2>Step 1：簡介</h2>
以下截取於<a href="https://www.geeksforgeeks.org/dsa/z-algorithm-linear-time-pattern-searching-algorithm/?utm_source=chatgpt.com">GeeksforGeeks（GfG）平台</a>

``` Markdown
In many programming problems involving strings, we often need to search for occurrences of a pattern inside a text. 
A classic approach like the naive string matching algorithm checks for the pattern at every index of the text, 
leading to a time complexity of O(n·m),
where n is the length of the text and m is the length of the pattern. 
This is inefficient for large inputs.

To address this, several efficient string matching algorithms exist one of them is the Z-Algorithm, 
which allows us to perform pattern matching in linear time. That means, it can find all matches in O(n + m) time.
```

<br/>簡言之，搜尋一串字串(文本)，用此演算法可以在線性時間內 O(n+m) 完成
<br/>※來源：Wiki
<br/><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/7e/Comparison_computational_complexity.svg/1024px-Comparison_computational_complexity.svg.png" width="100%" height="100%" />
<br/><br/>


<h2>Step 2：優缺點</h2>
優點具有以下：

{:class="table table-bordered"}

| 1. 保證線性時間複雜度 O(N+M) | ： | 無論文本、搜尋字串為何，永遠都為 O(N+M) | 
| 2. 實作相對簡單 |  ： | 代碼可讀性與實作容易，將 Z演算法陣列全部匹配計算完成即可 | 
| 3. 一次預處理，多次查詢 |  ： | 文本 + "#" + "搜尋字串" 搞定，極高效預處理 | 
| 5. 空間局部性好 |  ： | 演算法主要是順序掃描，對 CPU Cache 友好 | 


<br/>缺點：

{:class="table table-bordered"}
| 1. 空間複雜度較高 O(N+M) | ： | 如果文本 + 搜尋字串要 2GB 記憶體空間，那麼開銷至少要 4GB 記憶體空間才能執行 | 
| 2. 無法進行串流處理 |  ： | 需要完整的搜尋字串、文本才能開始此演算法，KMP 就可以逐步執行 | 
| 3. 對於非常短的模式，額外開銷較大 | ： | 文本少時，搜尋字串越長，建立陣列開銷大 | 
| 4. 不支援模式的動態修改 |  ： | 不同的搜尋字串、文本都需要重建陣列 | 
| 5. 對於部分場景不是最優 |  ： | 不能模糊匹配，只能精確匹配 | 

<br/><br/>

<h2>Step 3：常見的字串搜尋演算法 - 比較分析</h2>

{:class="table table-bordered"}
| 特性       | Z 演算法 | KMP     | Boyer-Moore | 暴力搜尋 |
| 時間複雜度 | O(N+M)   | O(N+M) | O(N/M) ~ O(N*M) | O(N*M) |
| 空間複雜度 | O(N+M)   | O(M)   | O(M)  | O(1)  |
| 實作難度   | 中等     | 中等    | 較難  | 簡單 |
| 直觀性     | 高       | 中     | 低    |  高 | 
| 串流處理   | 不支援   | 支援  | 支援 | 支援 | 
| 多模式搜尋 | 不適合   | 不適合 | 不適合 | 不適合 |

<br/>
<br/>高效能 + 可讀性高 有不可取代性，在極小專案中可以快速實現不算差的匹配搜尋，但是遠遠不適合在企業級應用中使用。
<br/><br/>

<h2>Step 4：應用場景建議</h2>
基本上除了理解匹配應用、小型專案外，不建議使用此字串演算法，有更多優秀有效的演算法應用

{:class="table table-bordered"}
| 適合的場景       | 不適合的場景 | 
| 1. 學術研究和教學（理解字串匹配原理） | 1. 處理巨大文件且記憶體有限   | 
| 2. 需要保證最壞情況性能的場合 | 2. 需要串流處理數據  |
| 3. 一次性搜尋，不需要串流處理   | 3. 搜尋多個不同的模式    | 
| 4. 記憶體充足的環境     | 4. 對空間效率要求極高 |
| 5. 需要額外利用 Z 陣列信息（如週期性分析）   | 5. 企業級應用（通常用更優化的演算法）   |

<br/>
<br/><br/>





<h1>第二部分：Z 演算法 - 實現</h1>
<h2>Step 1：完整代碼</h2>
完整代碼可以從<a href="https://github.com/gotoa1234/LeetCodeProblemSolvingBy_C_Sharp/blob/main/LeetCodePractice/LeetcodePractice/Easy/0796_Prime_Number_of_Set_Bits_in_Binary_Representation.cs">Source Code</a>下載，此代碼對應於 LeetCode 的 796 題，Prime Number of Set Bits in Binary Representation

<br/>主要以下 6 個步驟完成，整理複雜度 + 完整代碼框架如下：

``` C#
private bool ZAlgorithmSearch(string text, string pattern)
{
    // 1. 將模式、分隔符、文本組合成一個字串 (分隔符這邊用 # 要避免與匹配字串影響)
    var searchStr = $"{pattern}#{text}";

    var searchLength = searchStr.Length;// 組合字串的總長度
    var modelLength = pattern.Length;   // 模式字串的長度（用於後續判斷是否完整匹配）

    // 2. 初始化 Z 陣列 
    // 補充 : zBox[index]表示：從位置 index 開始的子字串與整個字串 s 的最長公共前綴長度
    // 例如 : s="ababab", zBox[2]=4 表示從位置2開始的 "abab" 與開頭的 "abab" 有 4 個字元匹配
    int[] zBox = new int[searchLength];

    // 3. 初始化 zBox 陣列
    // 目的： Z 字串演算法要將所有陣列的匹配長度找出
    int zBoxLeft = 0, zBoxRight = 0;

    // 4. 計算 zBox 陣列 從位置 1 開始（位置 0 可跳過，自己跟自己）
    for (int index = 1; index < searchLength; index++)
    {
        // 5-1. Index 在 zBox 之外 (index > zBoxRight)
        if (index > zBoxRight)
        {
            // 5-1-1. 當前位置在已知匹配區間之外，需要重新暴力比對
            zBoxLeft = zBoxRight = index;  // 將新的匹配區間起點設為 i

            // 5-1-2. 進行逐一匹配
            MatchAndSetArray(ref zBox, ref index, ref zBoxLeft, ref zBoxRight);

        }
        // 5-2. Index 在 Z-box 之內
        else
        {
            // 5-2-1. 當前位置在已知匹配區間內，可以利用之前計算出的 zBox 信息
            int offsetIndex = index - zBoxLeft;

            // 5-2-2. 可重用 : zBox 紀錄 (會進入此表示前一次有找到至少1個匹配)
            if (zBox[offsetIndex] < zBoxRight - index + 1)
            {
                zBox[index] = zBox[offsetIndex];
            }
            else// 5-2-3. 不可重用的狀況 
            {
                // 補充: LeetCode 不會進入此，但是 Z 演算法的完整實作必須包含它
                // 進入此的條件有以下：
                // - 1. 當 pattern 長度小於 text 時
                // - 2. 且存在重複或週期性結構       
                // 例如: pattern = "aaa", text = "aaaa"
                zBoxLeft = index;

                // 5-2-4. 進入匹配
                MatchAndSetArray(ref zBox,ref index, ref zBoxLeft, ref zBoxRight);
            }
        }
    }

    // 6-1. 檢查是否完全匹配 - 有目標數量表示有完全匹配
    for (int index = modelLength + 1; index < searchLength; index++)
    {
        if (zBox[index] == modelLength)
        {
            return true;
        }
    }
    return false;//6-2. 沒找到

    // 找出匹配量，並更新 zBox 陣列
    void MatchAndSetArray(ref int[] array, ref int zBoxIndex,
        ref int zBoxLeft, ref int zBoxRight)
    {
        // 1. 匹配
        while (zBoxRight < searchLength &&
               searchStr[zBoxRight - zBoxLeft] == searchStr[zBoxRight])
        {
            zBoxRight++;
        }

        // 2. 記錄匹配長度
        array[zBoxIndex] = zBoxRight - zBoxLeft;

        // 3. 因為 while 迴圈會讓 zBoxRight 多加 1，因此要減 1 校正
        zBoxRight--;
    }
}
```

<br/><br/>

<h2>Step 2：1. 快取策略容量上限</h2>
<br/><br/>


<h2>Step 3：LeetCode - 成功執行結果</h2>
附上此代碼確實可在 LeetCode 上執行 C# 版本

{:class="table table-bordered"}
| Runtime 範圍 | 42 ms ~ 91 ms |
| Runtime Best Beat | 67.10% |
| Memory 範圍 | 178.90 MB ~ 187.79 MB |
| Memory Best Beat | 95.48% |

<br/> <img src="/assets/image/Algorithm/Cache/LFU/001.png" width="80%" height="80%">
<br/><br/>


















<h1>第三部分：Z 演算法 - 圖解</h1>
<h2>Step 1：建樹 - 圖解</h2>
從建構式進入，會產生一個 Root 根結點

{:class="table table-bordered"}
| 文本 ： HERE IS A SIMPLE EXAMPLE ITEM  | 

<br/>然後建構式會觸發 **Insert()** 將文本拆成以下 6 個單詞：

{:class="table table-bordered"}
| HERE |
| IS |
| A |
| SIMPLE |
| EXAMPLE |
| ITEM |

<br/>並且依序建構成樹結構

<br/> <img src="/assets/image/Algorithm/StringSearch/Trie/001.png" width="50%" height="50%">
<br/> <img src="/assets/image/Algorithm/StringSearch/Trie/002.png" width="50%" height="50%">
<br/> <img src="/assets/image/Algorithm/StringSearch/Trie/003.png" width="50%" height="50%">
<br/> <img src="/assets/image/Algorithm/StringSearch/Trie/004.png" width="50%" height="50%">
<br/> <img src="/assets/image/Algorithm/StringSearch/Trie/005.png" width="50%" height="50%">
<br/> <img src="/assets/image/Algorithm/StringSearch/Trie/006.png" width="50%" height="50%">
<br/><br/>


<h2>Step 2：搜尋單詞</h2>
從 **Search()** 進入後，找出搜尋字串

{:class="table table-bordered"}
| 文本 ： HERE IS A SIMPLE EXAMPLE   | 
| 搜尋 ： EXAMPLE   | 

<br/>持續匹配直到回傳樹葉節點(最終節點)，而回傳是否找到，
<br/>EXAMPLE 都找到後，確認是否停留在樹葉節點上，若是就表示完全匹配。
<br/>※以正方形當作樹葉節點

<br/> <img src="/assets/image/Algorithm/StringSearch/Trie/Trie_Search.png" width="50%" height="50%">
<br/><br/>

<h2>Step 3：搜尋前綴</h2>
從 **StartsWith()** 進入後，找出搜尋字串

{:class="table table-bordered"}
| 文本 ： HERE IS A SIMPLE EXAMPLE   | 
| 搜尋 ： EXAM   | 

<br/>持續匹配直到搜尋字串全部匹配完成，回傳找到，否則回傳沒有
<br/>EXAM 都找到後，無論是否停留在樹葉上，
<br/> <img src="/assets/image/Algorithm/StringSearch/Trie/Trie_Prefix.png" width="50%" height="50%">
<br/><br/>
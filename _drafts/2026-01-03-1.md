---
layout: default_post
title:  "0001. LRU(Least Recently Used Cache) - 快取演算法 (Cache Algorithm) - 快取策略：最近最少使用"
excerpt: "演算法-快取策略"
tags:
- "Algorithm Cache"
- "Algorithm"
- "C#"
- "Asp.NET Core"
---

<div class="summary">
<br/>n：設定快取的上限數
<br/>時間複雜度(Time Complex)：O(1) ※ 取值 / 存值
<br/>空間複雜度： O(n)
<br/>範例檔案：<a href="https://github.com/gotoa1234/LeetCodeProblemSolvingBy_C_Sharp/blob/main/LeetCodePractice/LeetcodePractice/Mediun/_0146_LRU_Cache.cs">Source Code</a>
<br/>範例專案：<a href="https://github.com/gotoa1234/LeetCodeProblemSolvingBy_C_Sharp.git">Code Project</a>
<br/>基本介紹：本篇分為3大部分。
<br/>第一部分：LRU演算法 - 介紹
<br/>第二部分：LRU演算法 - 實現
<br/>第三部分：LRU演算法 - 圖解
</div>

<div class="title">
    <br/><hr class="titleinner">
	<span></span>
	<hr class="titleinner"><br/>
</div>


<br/><br/>
<h1>第一部分：LRU演算法 - 介紹</h1>
<h2>Step 1：簡介</h2>
以下截取於<a href="https://zh.wikipedia.org/zh-tw/Trie">Wiki</a>

``` Markdown
在電腦科學中，trie，又稱字首樹或字典樹，是一種有序樹，用於儲存關聯陣列，其中的鍵通常是字串。
與二元搜尋樹不同，鍵不是直接儲存在節點中，而是由節點在樹中的位置決定。
一個節點的所有子孫都有相同的字首，也就是這個節點對應的字串，而根節點對應空字串。
一般情況下，不是所有的節點都有對應的值，只有葉子節點和部分內部節點所對應的鍵才有相關的值。
```

<br/>簡言之，搜尋一串字串(文本)，用此演算法適合找相關聯前綴匹配的應用場景
<br/>※來源：Wiki
<br/><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/7e/Comparison_computational_complexity.svg/1024px-Comparison_computational_complexity.svg.png" width="100%" height="100%" />
<br/><br/>

<h2>Step 2：優缺點</h2>
優點具有以下：

{:class="table table-bordered"}
| 1. Hash插入  | ： | 高效的前綴搜索和插入操作。 | 
| 2. 查詢效率高  | ： | 使用Hash建樹的關係，因此查詢上能夠處理大量單詞，適合需要快速搜索和頻繁插入新單詞的應用。 | 

<br/>缺點：

{:class="table table-bordered"}
| 1. 預處理開銷大  | ： | 空間效率較低，特別是當文本很大時。 | 
| 2. 不適用單項查詢  | ： | 不適合處理單個長文本的模式匹配，因為構建字典樹的初始成本較高。 | 

<br/><br/>

<h2>Step 3：原理與應用</h2>

<br/>以下出自 Wiki ：

``` markdown
一個儲存了8個鍵的trie結構，"A", "to", "tea", "ted", "ten", "i", "in", "inn".
```

<br/>要先將文本建構成樹，查詢時再遍歷此樹，因此可實現相匹配接近的字串
<br/><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/be/Trie_example.svg/300px-Trie_example.svg.png?20211008170627" />
<br/><br/>



<h1>第二部分：LRU演算法 - 實現</h1>
<h2>Step 1：建構式 - 進入</h2>
在建構式中，會將傳入的字串做分割，以 ' ' 空白字元切出每個單詞。
<br/>其中 TrieNode 是一個類別節點

``` C#
private readonly TrieNode root;

/// <summary>
/// 1. 建構子
/// </summary>
/// <param name="text"></param>
public TrieAlgorithm(string text)
{
    root = new TrieNode();
    var textSplite = text.Split(' ');
    foreach (var item in textSplite)
    {
        this.Insert(item);
    }
}
```

<br/><br/>






<h1>第三部分：LRU演算法 - 圖解</h1>
<h2>Step 1：建樹 - 圖解</h2>
從建構式進入，會產生一個 Root 根結點

{:class="table table-bordered"}
| 文本 ： HERE IS A SIMPLE EXAMPLE ITEM  | 

<br/>然後建構式會觸發 **Insert()** 將文本拆成以下 6 個單詞：

{:class="table table-bordered"}
| HERE |
| IS |
| A |
| SIMPLE |
| EXAMPLE |
| ITEM |

<br/>並且依序建構成樹結構
<br/> <img src="/assets/image/Algorithm/Cache/LRU/001.png" width="50%" height="50%">
<br/> <img src="/assets/image/Algorithm/Cache/LRU/002.png" width="50%" height="50%">
<br/> <img src="/assets/image/Algorithm/Cache/LRU/003.png" width="50%" height="50%">
<br/> <img src="/assets/image/Algorithm/Cache/LRU/004.png" width="50%" height="50%">
<br/> <img src="/assets/image/Algorithm/Cache/LRU/005.png" width="50%" height="50%">
<br/> <img src="/assets/image/Algorithm/Cache/LRU/006.png" width="50%" height="50%">
<br/><br/>


<h2>Step 2：搜尋單詞</h2>
從 **Search()** 進入後，找出搜尋字串

{:class="table table-bordered"}
| 文本 ： HERE IS A SIMPLE EXAMPLE   | 
| 搜尋 ： EXAMPLE   | 

<br/>持續匹配直到回傳樹葉節點(最終節點)，而回傳是否找到，
<br/>EXAMPLE 都找到後，確認是否停留在樹葉節點上，若是就表示完全匹配。
<br/>※以正方形當作樹葉節點

<br/> <img src="/assets/image/Algorithm/StringSearch/Trie/Trie_Search.png" width="50%" height="50%">
<br/><br/>

<h2>Step 3：搜尋前綴</h2>
從 **StartsWith()** 進入後，找出搜尋字串

{:class="table table-bordered"}
| 文本 ： HERE IS A SIMPLE EXAMPLE   | 
| 搜尋 ： EXAM   | 

<br/>持續匹配直到搜尋字串全部匹配完成，回傳找到，否則回傳沒有
<br/>EXAM 都找到後，無論是否停留在樹葉上，
<br/> <img src="/assets/image/Algorithm/StringSearch/Trie/Trie_Prefix.png" width="50%" height="50%">
<br/><br/>
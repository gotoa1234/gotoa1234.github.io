---
layout: default_post
title: "0008. Docker Container - 零停機部署（Zero-downtime deployment） - 滾動部署策略"
excerpt: "Docker"
tags: 
- "Docker"
- "Docker-Compose"
- "Container"
- "Ubuntu"
- "Linux"
- "Nginx"
- "Jenkins"
- "Continuous Integration(CI)"
- "Continuous Deployment(CD)"
- "Redis"
- "StackExchangeRedis"
- "SignalR"
---

<div class="summary">
<br/>解決問題：部署 Docker Container 時，會先將舊的移除，然後再運行新的 Container 這時雖然只有短短幾秒，但是用戶畫面已經錯誤了
<br/>本篇的實作範例:<a href="https://github.com/gotoa1234/MyBlogExample/tree/main/ZeroDowntimeDeploymentForDockerWebsiteExample">零停機部署-滾動部署實作範例</a>
<br/>基本介紹：本篇分為 5 部分。
<br/>第一部分：問題描述 & 說明
<br/>第二部分：基礎架構 & 滾動部署策略
<br/>第三部分：實作調整方式 - 新舊版本共存解法
<br/>第四部分：實作調整方式 - 回滾困難解法
<br/>第五部分：DEMO 驗證成果
</div>

<div class="title">
    <br/><hr class="titleinner">
	<span></span>
	<hr class="titleinner"><br/>
</div>

<br/><br/>

<h1>第一部分：問題描述 & 說明</h1>

<h2>Step 1：問題描述 - 上帝視角 & 架構狀況</h2>
當使用者在訪問 Web Server 時，如果這時發生部署狀況 (如果是 Docker Container 會將整個**容器**移除再建立新的)

<br/>

{:class="table table-bordered"}
| 1. 開始部署 | Jenkins 開始進行更新，使用者可以正常訪問   |
| 2. 更新程式中  | 這時使用者會發現程式掛掉，無法使用  |
| 3. 部署完成  | 使用者可能 **重新整理** 畫面，恢復正常  |

<br/>但整個 CICD 過程中，使用者就會發現異常的狀況，本篇要解決此問題，因此要實現 **零停機部署** 讓用戶不會發現系統升級。
<br/> <img src="/assets/image/ContinuousDeployment/docker/2025_03_08/005.png" alt="" width="100%" height="100%" />
<br/><br/>

<h2>Step 2：使用者視角 (1. 開始部署)</h2>
Jenkins 在執行 1. 開始部署 階段時，使用者仍可以正常使用網站
<br/>※<a href="https://github.com/gotoa1234/MyBlogExample/tree/main/ZeroDowntimeDeploymentForDockerWebsiteExample">零停機部署-滾動部署實作範例</a>，中的SignalR 聊天室
<br/> <img src="/assets/image/ContinuousDeployment/docker/2025_03_08/001.png" alt="" width="50%" height="50%" />
<br/><br/>

<h2>Step 3：使用者視角 (2. 更新程式中)</h2>
這時用戶任意操作時，就會觸發 Container 被刪除，重建的狀況，此時用戶會看到 502
<br/> <img src="/assets/image/ContinuousDeployment/docker/2025_03_08/004.png" alt="" width="50%" height="50%" />
<br/>
<br/>Jenkins Server 這時在此階段
<br/> <img src="/assets/image/ContinuousDeployment/docker/2025_03_08/004_2.png" alt="" width="50%" height="50%" />
<br/><br/>


<h2>Step 4：對應腳本</h2>
<a href="https://github.com/gotoa1234/MyBlogExample/blob/main/ZeroDowntimeDeploymentForDockerWebsiteExample/JenkinFile">當前 Docker Container 部署腳本</a>
<br/>問題在腳本中的 Step 6. =>重建容器，如果不先將舊的容器刪除，必定會建立容器失敗，因此需要零停機部署的方案，來解決此問題

``` groovy
	// step 6. start - 重建容器，並且將舊的容器先刪除再運行
    stage('ReConstruct Container') {
      steps {
        sshPublisher(
            failOnError: true,
            publishers: [sshPublisherDesc(
            configName: "${env.TARGET_MACHINE_CREDENTIAL}", 
            transfers: [sshTransfer(
                excludes: '', 
                execCommand: "sudo docker stop ${env.PROJECT_NAME_FOR_DOCKER} && \
                                  docker rm ${env.PROJECT_NAME_FOR_DOCKER} || true && \
                                  docker run -e ASPNETCORE_ENVIRONMENT=Development --name ${env.PROJECT_NAME_FOR_DOCKER} -d -p 8090:8080 -p 8091:8081 \
                                  --mount type=bind,source=/var/dockervolumes/${env.PROJECT_NAME}/appsettings.json,target=/app/appsettings.json \
                                  --mount type=bind,source=/var/dockervolumes/${env.PROJECT_NAME}/appsettings.Development.json,target=/app/appsettings.Development.json \
                                  ${env.PROJECT_NAME_FOR_DOCKER}:latest", 
                execTimeout: 120000, 
                patternSeparator: '[, ]+')], 
            verbose: false)])
      }
    }    
	// step 6. end
```

<br/><br/>







<h1>第二部分：基礎架構 & 滾動部署策略</h1>

<h2>Step 1：介紹 - 零停機部署 - 方式</h2>
有以下 4 項主流的零停機部署方式，本篇選擇滾動部署說明：

{:class="table table-bordered"}
| 1. 滾動部署   | ：  | 逐一更新服務實例，新舊版本同時運作直到全部更新完成。 |
| 2. 藍綠部署   | ：  | 兩套環境，新版本部署到備用環境，測試完成後切換流量。 |
| 3. 紅黑部署   | ：  | 版本部署到獨立環境進行全面測試，確認無誤才切換流量。 |
| 4. 金絲雀部署 | ：  | 新版本導入小比例流量測試，觀察後逐步增加流量直到完全轉換。 | 

<br/>核心關鍵差異在於 **測試強度** ：

{:class="table table-bordered"}
| 1. 滾動部署   | ：  | 依賴健康檢查、基本功能性測試(可略)、自動化測試為主 |
| 2. 藍綠部署   | ：  | 依賴健康檢查、基本功能性測試(可略)、自動化測試為主 |
| 3. 紅黑部署   | ：  | 最嚴格的內測流程、全面功能性和非功能性測試、QA團隊完整驗證 |
| 4. 金絲雀部署 | ：  | 先進行基本驗證 -> 透過實際用戶反饋逐步驗證 -> 可及早發現問題並控制影響範圍  | 

<br/><br/>

<h2>Step 2：介紹 - 零停機部署 - 優缺點</h2>
選擇滾動部署的最大優點是 **低成本**，而且適合微服務、切割成小型的專案
<br/>在任何專案的初期都很適合使用，並且未來規模變大後，還可以再往上轉型成其他 **零停機部署**架構

{:class="table table-bordered"}
|     | 滾動部署 | 藍綠部署  | 紅黑部署 | 金絲雀部署 | 
| --- | ---     | ---      | ---     | ---       |
| 優點 | 資源利用率高 | 快速切換和回滾  | 驗證完整性高 | 風險最低 |
|     | 部署彈性大 | 無中斷服務  | 安全性強 | 問題及早發現 |
|     | 適合微服務架構 | 部署過程簡單  |   | 可精確控制流量 |
| 缺點 | 回滾困難  |  需要雙倍資源 | 可控制度高  |  監控複雜 |
|     | 新舊版本共存風險  |  資料庫同步複雜 | 部署時間最長  | 需要流量控制機制  |
|     |                 |               |              | 部署週期長       |
| 成本 | 中    | 高  | 高  | 高 |
| 複雜度 | 高    | 中  | 高  | 高  |
| 適合專案 | 微服務 | 核心業務  | 核心業務  | 複雜大型系統  |


<br/><br/>

<h2>Step 3：滾動部署 - 新舊版本共存風險(代碼端)</h2>
<a href="https://github.com/gotoa1234/MyBlogExample/tree/main/ZeroDowntimeDeploymentForDockerWebsiteExample">範例代碼</a>，為一個 Asp.net Core 的 WebSite 網站，後端 Server 實現了聊天室、API，因此我們需要解決以下問題，才能避免用戶發現：
<br/>代碼端：

{:class="table table-bordered"}
| 解決的問題    |  | 為何要解決  |
| --- | ---     | ---      | 
| 1. Session 持久化   | ：  | Session 保存在伺服器端，這時伺服器關掉，會導致當前用戶 Session 資料遺失，從而發現異常 |
| 2. SignalR 如何不斷線   | ：  | SignalR 在保持 WebSocket 的連線中，資料會停止發送與接收，從而發現異常 |

<br/><br/>


<h2>Step 4：滾動部署 - 回滾困難(伺服器端)</h2>
對於回滾困難的問題，利用 Nginx Load Balance 與 自動化腳本的處理，可以很輕鬆解決此問題
<br/>※雙福務運行為概念，可以在同一台機器上部署多套相同代碼，如果運行正常在進行切換，永遠只會有一個服務在上面正常運作
<br/>伺服器端：

{:class="table table-bordered"}
| 解決的問題    |  | 為何要解決  |
| --- | ---     | ---      | 
| 1. 雙服務運行   | ：  | 利用 Nginx 負載平衡，來分流當前用戶使用的服務，從而輕鬆回滾。 |
| 2. 健康檢查   | ：  | 在腳本中處理 Docker Container / 服務，檢查是否正常運行。知道是否正常才能進行判斷。 |
| 3. 自動化回滾腳本   | ：  | 當健康檢查後，可以決定是否繼續部署 or 還原舊版功能 |

<br/><br/>

<h2>Step 5：滾動部署 - 流程圖</h2>

<br/> <img src="/assets/image/ContinuousDeployment/docker/2025_03_01/001.png" alt="" width="50%" height="50%" />
<br/><br/>







<h1>第三部分：實作調整方式 - 新舊版本共存解法</h1>

<h2>Step 1：Session 持久化</h2>
可參考此篇：<a href="https://gotoa1234.github.io/2025/02/22/1.html">0085. 分布式 Session 實戰：使用 Redis 解決部署期間的用戶會話遺失問題</a>
<br/>並且本篇的範例代碼，已經使用該篇代碼，使用 Redis 進行 Session 持久化
<br/>


<h2>Step 2：SignalR 如何不斷線</h2>
SignalR 聊天室的代碼於此篇：<a href="https://gotoa1234.github.io//2024/06/02/1.html">0066. SignalR 橫向擴展部署 Server - Redis Backplane 解決方案</a>
<br/>並且本篇的範例代碼，已經使用該篇代碼調整
<br/><br/>


<h2>Step 3：SignalR 如何不斷線 - 重連機制</h2>
重連代碼的部分，完整版本需要前後端都處理，但是核心仍是 **前端**需要進行重連，後端即使沒有做完整的重連機制影響有限。
<br/>※補充：後端不做前端重連的額外處理，有可能讓舊的 SignalR 狀態資料還視為存活，如果與資料庫有互動，仍會有贓資料產生的疑慮。
<br/>
<br/>調整 Index.html 此段重連方式，採用漸進式重連

``` html

// 1. 創建 SignalR 連接
const connection = new signalR.HubConnectionBuilder()
    .withUrl("/UpdateHub", { accessTokenFactory: () => "I am jwtToken" })
    .withAutomaticReconnect([0, 2000, 10000, 30000]) // 2. 建立重試間隔時間（毫秒）
    .build();
// 3. 監聽重連事件
connection.onreconnecting((error) => {
    console.log("正在重新連接:", error);
});
// 4. 監聽連結成功事件
connection.onreconnected((connectionId) => {
    console.log("重新連接成功:", connectionId);
        });


```


<br/> <img src="/assets/image/ContinuousDeployment/docker/2025_03_08/006.png" alt="" width="50%" height="50%" />
<br/><br/>





<h1>第四部分：實作調整方式 - 回滾困難解法</h1>

<h2>Step 1：檢查 Ubuntu 主機版本</h2>
如圖，當主機非 LTS 版本時
<br/> <img src="/assets/image/ContinuousDeployment/docker/2025_03_01/001.png" alt="" width="50%" height="50%" />
<br/>











<h1>第五部分：DEMO 驗證成果</h1>



``` markdown
1. Jenkins 建置 
2. 建置過程 - 顯示畫面正常
3. 建置完成後 - 自動切換藍綠

# Server B 部署流程
1. 檢查 8080 正在運行
2. 在 8082 部署新版本
3. 等待 8082 健康檢查通過
4. 關閉 8080 的舊版本
# Nginx 會自動將流量導向 8082 和 Server C

# Server C 部署流程
1. 檢查 8080 正在運行
2. 在 8082 部署新版本
3. 等待 8082 健康檢查通過
4. 關閉 8080 的舊版本




如果調整成以下方式還是藍綠部署策略嗎?並且這個方式是否合理呢?

最初狀況：
- Server B 指向 8080 (自己)與 Server C
- Server C 指向 8080 (自己)與 Server B

開始 Jenkins 部署流程：
第一部分-部署新容器確保正常 : 
1-1. ServerB 建立新容器 8082 
1-2. 確定健康檢查可以正常運行
1-3. ServerC 建立新容器 8082 
1-4. 確定健康檢查可以正常運行

第二部分- 
如果第一部分有任何異常(包含健康檢查失敗) - 放棄這次部署
如果第一部分正常，Jenkins 開始以下流程：
2-1. 關閉 ServerC 8080 
2-2. 等待30秒，讓Server C 資料流向 ServerB 
3-3. 設定 ServerC Nginx 配置，並且指向到8082 
3-4. 先啟動 ServerC (這時已經是新容器)
3-5. 立刻關閉 ServerB 8080，強制分流到 ServerC 
3-6. 設定 ServerB Nginx 配置，並且指向到8082 
3-7. 啟動 Server B (這時已經是新容器)

第三部分-
1. 移除 Server B 舊的容器 8080 (下次會是8082 永遠這2個切換)
2. 移除 Server C 舊的容器 8080 (下次會是8082 永遠這2個切換)
3. 完成自動化部署


實務上是否可以採用以下策略 :
* 團隊先評估此次更新服務是否影響資料庫
   * [影響]資料庫 : 宣告停機時間，更新後同時啟動
   * [不影響]資料庫 : 藍綠部署，讓用戶無感

AI: 是的，這是一個非常務實的策略！讓我詳細說明：
```

<h2>Step 1：檢查 Ubuntu 主機版本</h2>
如圖，當主機非 LTS 版本時
<br/> <img src="/assets/image/ContinuousDeployment/docker/2025_03_01/001.png" alt="" width="50%" height="50%" />
<br/>


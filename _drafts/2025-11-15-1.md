---
layout: default_post
title: "0103. Asp.Net dotnet Core Web 安全兼具精確的補捉客戶端IP - ForwardedHeadersOptions "
excerpt: "C# 學習筆記"
tags:
  - "Asp.NET Core"
  - "Asp.NET Core Web MVC"
  - "C#"  
  - "Nginx"
  - "Docker"
---

<div class="summary">
<br/>範例所需：1. Visual Studio 2022 以上版本
<br/>&emsp;&emsp;&emsp;&emsp;&emsp;2. Linux 主機(本篇用 Ubuntu 22.04)
<br/>&emsp;&emsp;&emsp;&emsp;&emsp;3. Linux 主機已安裝 Nginx
<br/>&emsp;&emsp;&emsp;&emsp;&emsp;4. Linux 主機已安裝 Docker
<br/>範例檔案：<a href="https://github.com/gotoa1234/MyBlogExample/tree/main/UseForwardedHeadersExample">本篇範例代碼</a>
<br/>解決問題：在 Asp.Net Web 中，如何更精確的補捉用戶端的真實IP，並實際部署 Nginx + Docker 的方式說明此設定的差異
<br/>基本介紹：本篇分為五大部分。
<br/>第一部分：前置作業 - 環境架構
<br/>第二部分：問題描述
<br/>第三部分：解決方案
<br/>第四部分：DEMO 成果
<br/>第五部分：生產環境實務討論
</div>

<div class="title">
    <br/><hr class="titleinner">
  <span></span>
  <hr class="titleinner"><br/>
</div>

<br/><br/>
<h1>第一部分：前置作業 - 環境架構</h1>

<h2>Step 1：前置作業 - 環境架構</h2>
以下是此次說明用到的環境架構

{:class="table table-bordered"}
| 角色  |  | 說明 | 
| ---  | ---  | --- | 
| 1. 用戶端  | ： | 訪問的用戶 IP : 192.168.242.76 | 
| 2. 伺服器主機  | ： | 提供用戶訪問的 Web 機器，機器 IP：192.168.51.93  | 
| 3. Nginx (伺服器內)  | ： | 安裝於伺服器主機，並且與容器 8888 Port 綁定，對外反向 8889 | 
|                     |   | 反向代理後完整路徑： 192.168.51.93:8889  | 
| 4. 容器 (伺服器內)  | ： | 安裝於伺服器主機，Docker 容器，使用 8888 Port  | 
|                     |   | 用戶直連完整路徑： 192.168.51.93:8888  | 

<br/><img src="/assets/image/LearnNote/2025_11_15/002.png" alt="" width="50%" height="50%" />width="30%" height="30%" />
<br/><br/>


<h2>Step 2：前置作業 - Web 開放的 API</h2>
並且運行的 Web 應用程式安裝在容器上，並且開放了以下端口：
<br/>※取得 IP 使用的屬性 : **HttpContext.Connection.RemoteIpAddress**

``` C#
/// <summary>
/// 當前訪問者(用戶) 後端紀錄的 IP
/// </summary>        
[HttpGet]
public IActionResult CallAPI()
{
    var remoteIp = HttpContext.Connection.RemoteIpAddress;
    // 方便 Demo 說明轉換成純 IPv4
    var ipv4 = remoteIp?.MapToIPv4();
    var result = new
    {
        RemoteIp = ipv4.ToString(),
        Scheme = HttpContext.Request.Scheme,
        Host = HttpContext.Request.Host.Value
    };
    return Ok(result);
}
```

<br/>並且對應的呼叫 API 路由如下：

``` Markdown
http://{Domain}//Home//CallAPI
```

<br/><img src="/assets/image/LearnNote/2025_11_15/002.png" alt="" width="50%" height="50%" />width="30%" height="30%" />
<br/><br/>






<h1>第二部分：問題描述</h1>

<h2>Step 1：用戶端-直連 - 可以正常取得</h2>
我們透過本機電腦訪問容器位址，中間過程沒有任何 **反向代理** ，視為直連


<br/><img src="/assets/image/LearnNote/2025_11_15/003.png" alt="" width="50%" height="50%" />width="30%" height="30%" />
<br/>
<br/>輸入以下 URL 網址列，可以看到 API 反饋的 IP 為 **192.168.242.76** 正確的獲得了訪問者的 IP

``` Markdown
http://192.168.51.93:8888/Home/CallAPI
```

<br/><img src="/assets/image/LearnNote/2025_11_15/003-2.png" alt="" width="50%" height="50%" />width="30%" height="30%" />
<br/><br/>

<h2>Step 2：用戶端-經過代理 - 問題出現</h2>
我們透過本機電腦訪問 Nginx 對外位址，有 **經過反向代理**

<br/><img src="/assets/image/LearnNote/2025_11_15/004.png" alt="" width="50%" height="50%" />width="30%" height="30%" />
<br/>
<br/>輸入以下 URL 網址列，可以看到 API 反饋的 IP 為 **192.168.51.93** 這是 **伺服器IP** 而非用戶IP

``` Markdown
http://192.168.51.93:8889/Home/CallAPI
```

<br/><img src="/assets/image/LearnNote/2025_11_15/004-2.png" alt="" width="50%" height="50%" />width="30%" height="30%" />
<br/><br/>


<h2>Step 3：問題描述 - 為何無法取得真實 IP </h2>
這實際上與轉發標頭 **X-Forwarded-For** 有關，以下是不同訪問模式下的轉發層級：

{:class="table table-bordered"}
| 用戶訪問模式  |  | 經過路徑 | 層數(自己算1) |
| ---  | ---  | --- | ---  | -- |
| 直連  | ： | 用戶 => 容器  | 1 |
| 經過代理  | ： | 用戶 => Nginx -> 容器 | 2 |

<br/>直連時,`HttpContext.Connection.RemoteIpAddress` 會顯示**用戶的真實 IP**
<br/>經過代理時,`HttpContext.Connection.RemoteIpAddress` 只能看到**最近一層代理的 IP (Nginx IP)**,而不是用戶的真實 IP
<br/><br/>


<h1>第三部分：解決方案</h1>

<h2>Step 1：範例代碼架構</h2>
打開<a href="https://github.com/gotoa1234/MyBlogExample/tree/main/UseForwardedHeadersExample">本篇範例代碼</a>後，架構基本分成以下：
<br/>※ **調整前專案** ：NotUseForwardedHeadersExample
<br/>※ **調整後專案** ：UseForwardedHeadersExample

{:class="table table-bordered"}
| 1. 初始化配置  | ： | 初始化配置 ForwardedHeadersOptions ，使其可觀察到真實 IP  | 
| 2. 控制器  | ： | 取得 HttpContext 組態資料  | 
| 3. Web 檢視器  | ： | 響應 API 的結果到頁面上，便於觀察 | 
| 4. Dockerfile  | ： | 容器化部署會用到的 Dockerfile | 

<br/><img src="/assets/image/LearnNote/2025_11_15/005.png" alt="" width="50%" height="50%" />width="30%" height="30%" />
<br/><br/>


<h2>Step 2：解決方案 - 設定初始化配置</h2>
在初始化配置中設定以下，添加 ForwardedHeaders，以下是解決此問題所需參數與說明：

{:class="table table-bordered"}
| 1. ForwardedHeaders  | 處理 X-Forwarded-For (客戶端真實 IP)  | 
|                      | 處理 X-Forwarded-Proto (原始協定 http/https)  | 
| 2. ForwardLimit  | ： | 限制最多處理幾層代理 | 

<br/>

``` C# 
using Microsoft.AspNetCore.HttpOverrides;
try
{
    var builder = WebApplication.CreateBuilder(args);

    // Add services to the container.
    builder.Services.AddControllersWithViews();

    var app = builder.Build();

    // 1. 添加 ForwardedHeaders 
    var forwardedHeadersOptions = new ForwardedHeadersOptions
    {
        ForwardedHeaders = ForwardedHeaders.XForwardedFor | ForwardedHeaders.XForwardedProto,
        ForwardLimit = 5
    };  
    app.UseForwardedHeaders(forwardedHeadersOptions);

    //... 略

    app.Run();

}
catch (Exception ex)
{
    Console.WriteLine(ex);
}

```

<br/>至此設定完成後，可以直接進到 **第四部分：DEMO 成果** ，第三部份後半段為安全性、建議說明
<br/><br/>




<h2>Step 3：完整配置 ForwardedHeaders </h2>
以下是說明 ForwardedHeaders 的其他參數，基本上會用到的只有 3 種參數配置，其餘多半在生產環境上可以不用配置

{:class="table table-bordered"}
| 參數 | 用途 | 生產環境是否必須 | 說明 |
| --- | --- | --- | --- |
| 1. ForwardedHeaders  | 指定要處理哪些轉發標頭(Header)  | - | 依照需求設定 |
| 2. ForwardLimit      | 限制最多處理幾層代理 | √ | 合理配置數值，設為 Null 會為不限制，有風險 |
| 3. KnownProxies      | 信任的代理 IP 清單 | √ | 依照生產環境配置，信任已知的負載平衡、反向代理IP | 
| 4. KnownNetworks     | 信任的網路區段 | √ | 依照生產環境配置網路區段，信任內網區段 | 
| 5. AllowedHosts      | 允許的主機名 | X | HostFiltering 中介軟體專門處理主機名驗證，並免同時使用 |
| 6. RequireHeaderSymmetry  | 標頭對稱性檢查 | X | 預設 False ，若需要強制所有代理層標頭一致才需要 | 
| 7. ForwardedForHeaderName    | 自訂標頭名稱 | X | 遵循標頭規範名稱，請勿自訂名稱，通常用來做為測試，或客製化使用 |
| 8. OriginalForHeaderName    | 用於保存原始標頭值 | X | 不用，中間的代理紀錄更為合適 |
| 9. OriginalProtoHeaderName    | 用於保存原始標頭值 | X | 不用，中間的代理紀錄更為合適 |

<br/>以下是預設代碼參考：

``` C# 
var forwardedHeadersOptions = new ForwardedHeadersOptions
{
    // 處理所有轉發標頭
    ForwardedHeaders = ForwardedHeaders.XForwardedFor 
                     | ForwardedHeaders.XForwardedProto 
                     | ForwardedHeaders.XForwardedHost,        
    // 合理的轉發                
    ForwardLimit = 5,    
};

// 信任特定的代理伺服器
forwardedHeadersOptions.KnownProxies.Add(IPAddress.Parse("10.0.0.100"));

// 或信任整個內網
forwardedHeadersOptions.KnownNetworks.Add(
    new IPNetwork(IPAddress.Parse("10.0.0.0"), 8)
);
forwardedHeadersOptions.KnownNetworks.Add(
    new IPNetwork(IPAddress.Parse("172.16.0.0"), 12)
);
forwardedHeadersOptions.KnownNetworks.Add(
    new IPNetwork(IPAddress.Parse("192.168.0.0"), 16)
);

```

<br/><br/>




<br/><br/>
<h1>第四部分：DEMO 成果</h1>

<h2>Step 1：測試圖片 - 低解析度圖片</h2>
圖片同這篇範例：<a href="https://gotoa1234.github.io/2025/10/04/1.html">0101. ASP.NET Core 整合 Tesseract OCR：從原始圖片到文字識別的完整實作</a>
<br/>使用較低解析度的圖
<br/><img src="/assets/image/LearnNote/2025_10_04/div.png" alt="" width="50%" height="50%" />
<br/><br/>


<br/><br/>
<h1>第五部分：生產環境實務討論</h1>

<h2>Step 1：測試圖片 - 低解析度圖片</h2>
圖片同這篇範例：<a href="https://gotoa1234.github.io/2025/10/04/1.html">0101. ASP.NET Core 整合 Tesseract OCR：從原始圖片到文字識別的完整實作</a>
<br/>使用較低解析度的圖
<br/><img src="/assets/image/LearnNote/2025_10_04/div.png" alt="" width="50%" height="50%" />
<br/><br/>



